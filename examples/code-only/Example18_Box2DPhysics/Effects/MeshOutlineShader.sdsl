shader MeshOutlineShader : ShaderBase, Transformation, Texturing, PositionStream4
{
    stage stream float3 Normal : NORMAL;

    float4 Color;
    float Intensity;
    float OutlineThickness; // normalized thickness [0.0, 1.0], 0.0 = invisible, 1.0 = fills shape
    int ShapeType; // 0 = rectangle, 2 = circle
    float Radius; // actual mesh radius, passed from C#

    cbuffer PerView
    {
        stage float4 Viewport;
    }

    float4 projToWorld(in float4 pos, in float3 normal)
    {
        float3 scaling = normal * (WorldScale - 1);
        return mul(pos + float4(scaling.x, scaling.y, scaling.z, 0), WorldViewProjection);
    }

    stage override void VSMain()
    {
        streams.ShadingPosition = projToWorld(streams.Position, streams.Normal);
    }

    stage override void PSMain()
    {
        float2 pos = streams.Position.xy; // Local mesh position, centered at (0,0)
        bool isOutline = false;

        if (ShapeType == 2) // Circle
        {
            float minVisibleThickness = 0.2f * Radius; // scale min thickness by radius
            float maxThickness = Radius; // Maximum fills the shape
            float outlineWidth = minVisibleThickness + (OutlineThickness * (maxThickness - minVisibleThickness));
            float dist = length(pos);
            isOutline = (dist > Radius - outlineWidth) && (dist <= Radius);
        }
        else // Rectangle
        {
            float2 uv = pos + 0.5; // Convert [-0.5,0.5] to [0,1] if mesh is centered
            float2 edgeDist = min(uv, 1.0 - uv);
            float minDist = min(edgeDist.x, edgeDist.y);
            float minVisibleThickness = 0.02f; // Minimum thickness to be visible
            float maxThickness = 0.5; // Maximum fills the shape
            float outlineWidth = minVisibleThickness + (OutlineThickness * (maxThickness - minVisibleThickness));
            isOutline = (minDist <= outlineWidth);
        }

        if (!isOutline)
            discard;

        streams.ColorTarget = Color * Intensity;
    }
};