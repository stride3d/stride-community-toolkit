shader MeshOutlineShader : ShaderBase, Transformation, Texturing, PositionStream4
{
    stage stream float3 Normal : NORMAL;

    float4 Color;
    float Intensity;
    float OutlineThickness; // thickness in pixels
    int ShapeType; // 0 = rectangle, 2 = circle
    float Radius; // actual mesh radius, passed from C#
    float PixelScale; // world-to-pixel scale, passed from C#
    float4 FillColor; // Add this for blending (optional)
    float AntiAlias; // e.g. 1.0f
    stage StructuredBuffer<float2> PolygonVertices;
    stage int PolygonVertexCount;

    cbuffer PerView
    {
        stage float4 Viewport;
    }

    float4 projToWorld(in float4 pos, in float3 normal)
    {
        float3 scaling = normal * (WorldScale - 1);
        return mul(pos + float4(scaling.x, scaling.y, scaling.z, 0), WorldViewProjection);
    }

    float cross2d(float2 v1, float2 v2)
    {
        return v1.x * v2.y - v1.y * v2.x;
    }

    // Signed distance function for convex polygon
    float sdConvexPolygon(float2 p, int count)
    {
        float d = dot(p - PolygonVertices[0], p - PolygonVertices[0]);
        float side = -1.0;
        int j = count - 1;
        for (int i = 0; i < count; ++i)
        {
            float2 e = PolygonVertices[i] - PolygonVertices[j];
            float2 w = p - PolygonVertices[j];
            float we = dot(w, e);
            float2 b = w - e * clamp(we / dot(e, e), 0.0, 1.0);
            float bb = dot(b, b);
            if (bb < d) d = bb;
            float s = cross2d(w, e);
            if (s >= 0.0) side = 1.0;
            j = i;
        }
        return side * sqrt(d);
    }

    stage override void VSMain()
    {
        streams.ShadingPosition = projToWorld(streams.Position, streams.Normal);
    }

    stage override void PSMain()
    {
        float2 pos = streams.Position.xy; // Local mesh position, centered at (0,0)
        bool isOutline = false;
        float alpha = 1.0;

        if (ShapeType == 2) // Circle
        {
            float outlineWidth = OutlineThickness / PixelScale;
            float aa = AntiAlias / PixelScale; // anti-aliasing width in world units
            float dist = length(pos);

            // Smooth transition for anti-aliased border
            float edge0 = Radius - outlineWidth - aa;
            float edge1 = Radius - outlineWidth + aa;
            float edge2 = Radius - aa;
            float edge3 = Radius + aa;

            float outlineMask = smoothstep(edge0, edge1, dist) * (1.0 - smoothstep(edge2, edge3, dist));
            alpha = outlineMask;

            if (alpha < 0.01) discard;

            // Blend outline color with fill color near the edge
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
        else // Polygon/Rectangle/Triangle
        {
            float dist = abs(sdConvexPolygon(pos, PolygonVertexCount));
            float outlineWidth = OutlineThickness / PixelScale;
            float aa = AntiAlias / PixelScale; // anti-aliasing width in world units

            // Anti-aliased mask for the outline band
            float edge0 = outlineWidth - aa;
            float edge1 = outlineWidth + aa;
            float outlineMask = 1.0 - smoothstep(edge0, edge1, dist);

            if (outlineMask < 0.01) discard;

            // Optional: blend with fill color for a softer look
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
    }
};