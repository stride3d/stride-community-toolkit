shader MeshOutlineShader : ShaderBase, Transformation, Texturing, PositionStream4
{
    stage stream float3 Normal : NORMAL;

    float4 Color;
    float Intensity;
    float OutlineThickness; // thickness in pixels
    int ShapeType; // 0 = rectangle, 2 = circle
    float Radius; // actual mesh radius, passed from C#
    float PixelScale; // world-to-pixel scale, passed from C#
    float4 FillColor; // Add this for blending (optional)
    float AntiAlias; // e.g. 1.0f

    cbuffer PerView
    {
        stage float4 Viewport;
    }

    float4 projToWorld(in float4 pos, in float3 normal)
    {
        float3 scaling = normal * (WorldScale - 1);
        return mul(pos + float4(scaling.x, scaling.y, scaling.z, 0), WorldViewProjection);
    }

    stage override void VSMain()
    {
        streams.ShadingPosition = projToWorld(streams.Position, streams.Normal);
    }

    stage override void PSMain()
    {
        float2 pos = streams.Position.xy; // Local mesh position, centered at (0,0)
        bool isOutline = false;
        float alpha = 1.0;

        if (ShapeType == 2) // Circle
        {
            float outlineWidth = OutlineThickness / PixelScale;
            float aa = AntiAlias / PixelScale; // anti-aliasing width in world units
            float dist = length(pos);

            // Smooth transition for anti-aliased border
            float edge0 = Radius - outlineWidth - aa;
            float edge1 = Radius - outlineWidth + aa;
            float edge2 = Radius - aa;
            float edge3 = Radius + aa;

            float outlineMask = smoothstep(edge0, edge1, dist) * (1.0 - smoothstep(edge2, edge3, dist));
            alpha = outlineMask;

            if (alpha < 0.01) discard;

            // Blend outline color with fill color near the edge
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
        else // Rectangle (similar logic can be applied)
        {
            float2 uv = pos + 0.5; // Convert [-0.5,0.5] to [0,1] if mesh is centered
            float2 edgeDist = min(uv, 1.0 - uv);
            float minDist = min(edgeDist.x, edgeDist.y);
            float minVisibleThickness = 0.02f; // Minimum thickness to be visible
            float maxThickness = 0.5; // Maximum fills the shape
            float outlineWidth = minVisibleThickness + (OutlineThickness * (maxThickness - minVisibleThickness));
            isOutline = (minDist <= outlineWidth);

            if (!isOutline) discard;

            streams.ColorTarget = Color * Intensity;
        }
    }
};