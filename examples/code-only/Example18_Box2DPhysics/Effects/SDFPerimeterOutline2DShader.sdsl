shader SDFPerimeterOutline2DShader : ShaderBase, Transformation, Texturing, PositionStream4
{
    stage stream float3 Normal : NORMAL;

    float4 Color;
    float Intensity;
    float OutlineThickness; // thickness in pixels
    int ShapeType; // 0 = polygon/rect, 1 = capsule (Y axis), 2 = circle
    float Radius; // actual mesh radius, passed from C#
    float PixelScale; // world-to-pixel scale, passed from C#
    float4 FillColor; // Add this for blending (optional)
    float AntiAlias; // e.g. 1.0f
    float CapsuleHalfHeight; // NEW: (halfHeight - radius) portion of capsule along +Y/-Y
    float2 CapsuleEndA;             // OPTIONAL: endpoint A (local space)
    float2 CapsuleEndB;             // OPTIONAL: endpoint B (local space)
    stage StructuredBuffer<float2> PolygonVertices;
    stage int PolygonVertexCount;

    cbuffer PerView
    {
        stage float4 Viewport;
    }

    float4 projToWorld(in float4 pos, in float3 normal)
    {
        float3 scaling = normal * (WorldScale - 1);
        return mul(pos + float4(scaling.x, scaling.y, scaling.z, 0), WorldViewProjection);
    }

    float cross2d(float2 v1, float2 v2)
    {
        return v1.x * v2.y - v1.y * v2.x;
    }

    // Signed distance function for convex polygon
    float sdConvexPolygon(float2 p, int count)
    {
        float d = dot(p - PolygonVertices[0], p - PolygonVertices[0]);
        float side = -1.0;
        int j = count - 1;
        for (int i = 0; i < count; ++i)
        {
            float2 e = PolygonVertices[i] - PolygonVertices[j];
            float2 w = p - PolygonVertices[j];
            float we = dot(w, e);
            float2 b = w - e * clamp(we / dot(e, e), 0.0, 1.0);
            float bb = dot(b, b);
            if (bb < d) d = bb;
            float s = cross2d(w, e);
            if (s >= 0.0) side = 1.0;
            j = i;
        }
        return side * sqrt(d);
    }

    // Distance to capsule defined by segment AB and radius r
    float sdCapsuleSeg(float2 p, float2 a, float2 b, float r)
    {
        float2 pa = p - a;
        float2 ba = b - a;
        float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
        return length(pa - ba * h) - r;
    }

    stage override void VSMain()
    {
        streams.ShadingPosition = projToWorld(streams.Position, streams.Normal);
    }

    stage override void PSMain()
    {
        float2 pos = streams.Position.xy;
        float outlineWidth = OutlineThickness / PixelScale;
        float aa = AntiAlias / PixelScale;

        if (ShapeType == 2) // Circle
        {
            float dist = length(pos);
            float edge0 = Radius - outlineWidth - aa;
            float edge1 = Radius - outlineWidth + aa;
            float edge2 = Radius - aa;
            float edge3 = Radius + aa;

            float outlineMask = smoothstep(edge0, edge1, dist) * (1.0 - smoothstep(edge2, edge3, dist));
            if (outlineMask < 0.01) discard;
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
        else if (ShapeType == 0) // Capsule (vertical)
        {
            // If endpoints not provided, derive from half height (vertical orientation default)
            float2 a = CapsuleEndA;
            float2 b = CapsuleEndB;
            // Fallback if (0,0)
            if (all(a == 0) && all(b == 0))
            {
                a = float2(0, -CapsuleHalfHeight);
                b = float2(0,  CapsuleHalfHeight);
            }

            float sd = sdCapsuleSeg(pos, a, b, Radius);
            float inner0 = -outlineWidth - aa;
            float inner1 = -outlineWidth + aa;
            float outer0 = -aa;
            float outer1 = aa;
            float innerBlend = smoothstep(inner0, inner1, sd);
            float outerBlend = 1.0 - smoothstep(outer0, outer1, sd);
            float outlineMask = innerBlend * outerBlend;
            if (outlineMask < 0.01) discard;
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
        else // Polygon/Rectangle/Triangle
        {
            float dist = abs(sdConvexPolygon(pos, PolygonVertexCount));
            float edge0 = outlineWidth - aa;
            float edge1 = outlineWidth + aa;
            float outlineMask = 1.0 - smoothstep(edge0, edge1, dist);
            if (outlineMask < 0.01) discard;
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
    }
};