shader SDFPerimeterOutline2DShader : ShaderBase, Transformation, Texturing, PositionStream4
{
    stage stream float3 Normal : NORMAL;

    float4 Color;
    float Intensity;
    float OutlineThickness; // thickness in pixels
    int ShapeType; // 0 = polygon/rect, 1 = capsule (Y axis), 2 = circle
    float Radius; // actual mesh radius, passed from C#
    float PixelScale; // world-to-pixel scale, passed from C#
    float4 FillColor; // Add this for blending (optional)
    float AntiAlias; // e.g. 1.0f
    float CapsuleHalfHeight; // NEW: (halfHeight - radius) portion of capsule along +Y/-Y
    stage StructuredBuffer<float2> PolygonVertices;
    stage int PolygonVertexCount;

    cbuffer PerView
    {
        stage float4 Viewport;
    }

    float4 projToWorld(in float4 pos, in float3 normal)
    {
        float3 scaling = normal * (WorldScale - 1);
        return mul(pos + float4(scaling.x, scaling.y, scaling.z, 0), WorldViewProjection);
    }

    float cross2d(float2 v1, float2 v2)
    {
        return v1.x * v2.y - v1.y * v2.x;
    }

    // Signed distance function for convex polygon
    float sdConvexPolygon(float2 p, int count)
    {
        float d = dot(p - PolygonVertices[0], p - PolygonVertices[0]);
        float side = -1.0;
        int j = count - 1;
        for (int i = 0; i < count; ++i)
        {
            float2 e = PolygonVertices[i] - PolygonVertices[j];
            float2 w = p - PolygonVertices[j];
            float we = dot(w, e);
            float2 b = w - e * clamp(we / dot(e, e), 0.0, 1.0);
            float bb = dot(b, b);
            if (bb < d) d = bb;
            float s = cross2d(w, e);
            if (s >= 0.0) side = 1.0;
            j = i;
        }
        return side * sqrt(d);
    }

    // Signed distance for a vertical (Y-axis) capsule with spherical ends:
    // total half extent in Y = CapsuleHalfHeight + Radius
    float sdCapsuleY(float2 p, float halfSegment, float r)
    {
        // Shift so we treat the cylindrical part length = 2*halfSegment (excluding hemispheres)
        // Classic 2D capsule SDF aligned to Y:
        float2 q = float2(p.x, abs(p.y)) - float2(0.0, halfSegment);
        float2 d = max(q, 0.0);
        return min(max(q.x, q.y), 0.0) + length(d) - r;
    }

    stage override void VSMain()
    {
        streams.ShadingPosition = projToWorld(streams.Position, streams.Normal);
    }

    stage override void PSMain()
    {
        float2 pos = streams.Position.xy;
        float outlineWidth = OutlineThickness / PixelScale;
        float aa = AntiAlias / PixelScale;

        if (ShapeType == 2) // Circle
        {
            float dist = length(pos);
            float edge0 = Radius - outlineWidth - aa;
            float edge1 = Radius - outlineWidth + aa;
            float edge2 = Radius - aa;
            float edge3 = Radius + aa;

            float outlineMask = smoothstep(edge0, edge1, dist) * (1.0 - smoothstep(edge2, edge3, dist));
            if (outlineMask < 0.01) discard;
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
        else if (ShapeType == 0) // Capsule (vertical)
        {
            // Signed distance (negative inside)
            float sd = sdCapsuleY(pos, CapsuleHalfHeight, Radius);
            // We want band near surface: sd ~= 0. Interior is sd < 0.
            // Build inner & outer smooth edges around 0 and -outlineWidth.
            float inner0 = -outlineWidth - aa;
            float inner1 = -outlineWidth + aa;
            float outer0 = -aa;
            float outer1 = aa;

            float innerBlend = smoothstep(inner0, inner1, sd);          // Rises as we approach inner edge
            float outerBlend = 1.0 - smoothstep(outer0, outer1, sd);    // Falls past outer edge
            float outlineMask = innerBlend * outerBlend;

            if (outlineMask < 0.01) discard;
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
        else // Polygon/Rectangle/Triangle
        {
            float dist = abs(sdConvexPolygon(pos, PolygonVertexCount));
            float edge0 = outlineWidth - aa;
            float edge1 = outlineWidth + aa;
            float outlineMask = 1.0 - smoothstep(edge0, edge1, dist);
            if (outlineMask < 0.01) discard;
            streams.ColorTarget = lerp(FillColor, Color * Intensity, outlineMask);
        }
    }
};