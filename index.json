{
  "api/Stride.CommunityToolkit.Engine.CameraComponentExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.CameraComponentExtensions.html",
    "title": "Class CameraComponentExtensions | Stride Community Toolkit",
    "keywords": "Class CameraComponentExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll public static class CameraComponentExtensions Inheritance object CameraComponentExtensions Methods GetPickRay(CameraComponent, Vector2) public static Ray GetPickRay(this CameraComponent camera, Vector2 screenPosition) Parameters camera CameraComponent screenPosition Vector2 Returns Ray LogicDirectionToWorldDirection(CameraComponent, Vector2) public static Vector3 LogicDirectionToWorldDirection(this CameraComponent camera, Vector2 logicDirection) Parameters camera CameraComponent logicDirection Vector2 Returns Vector3 LogicDirectionToWorldDirection(CameraComponent, Vector2, Vector3) public static Vector3 LogicDirectionToWorldDirection(this CameraComponent camera, Vector2 logicDirection, Vector3 upVector) Parameters camera CameraComponent logicDirection Vector2 upVector Vector3 Returns Vector3 Raycast(CameraComponent, ScriptComponent, Vector2, CollisionFilterGroups, CollisionFilterGroupFlags) Performs a raycasting operation from the specified CameraComponent's position through the specified screen position in world coordinates, and returns information about the hit result. public static HitResult Raycast(this CameraComponent camera, ScriptComponent component, Vector2 screenPosition, CollisionFilterGroups collisionGroups = CollisionFilterGroups.DefaultFilter, CollisionFilterGroupFlags collisionFlags = CollisionFilterGroupFlags.DefaultFilter) Parameters camera CameraComponent The CameraComponent from which the ray should be cast. component ScriptComponent The ScriptComponent which has the Simulation to run the Cast in. screenPosition Vector2 The screen position (in world coordinates) where the ray should be cast through. collisionGroups CollisionFilterGroups Optional. The collision filter group to consider during the raycasting. Default is CollisionFilterGroups.DefaultFilter. collisionFlags CollisionFilterGroupFlags Optional. The collision filter group flags to consider during the raycasting. Default is CollisionFilterGroupFlags.DefaultFilter. Returns HitResult A HitResult containing information about the hit result, including the hit location and other collision data. RaycastMouse(CameraComponent, ScriptComponent, CollisionFilterGroups, CollisionFilterGroupFlags) Performs a raycasting operation from the specified CameraComponent's position through the mouse cursor position in screen coordinates, and returns information about the hit result. public static HitResult RaycastMouse(this CameraComponent camera, ScriptComponent component, CollisionFilterGroups collisionGroup = CollisionFilterGroups.DefaultFilter, CollisionFilterGroupFlags collisionFilterGroupFlags = CollisionFilterGroupFlags.DefaultFilter) Parameters camera CameraComponent The CameraComponent from which the ray should be cast. component ScriptComponent The ScriptComponent from which the Input.MousePosition should be taken. collisionGroup CollisionFilterGroups Optional. The collision filter group to consider during the raycasting. Default is CollisionFilterGroups.DefaultFilter. collisionFilterGroupFlags CollisionFilterGroupFlags Optional. The collision filter group flags to consider during the raycasting. Default is CollisionFilterGroupFlags.DefaultFilter. Returns HitResult A HitResult containing information about the hit result, including the hit location and other collision data. ScreenPointToRay(CameraComponent, Vector2) Returns near and far vector based on a ray going from camera through a screen point. The ray is in world space, starting on the near plane of the camera and going through position's (x,y) pixel coordinates on the screen. public static (Vector4 VectorNear, Vector4 VectorFar) ScreenPointToRay(this CameraComponent camera, Vector2 screenPosition) Parameters camera CameraComponent screenPosition Vector2 Returns (Vector4 VectorNear, Vector4 VectorFar) ScreenToWorldPoint(CameraComponent, Vector3) Converts the screen position to a point in world coordinates. public static Vector3 ScreenToWorldPoint(this CameraComponent cameraComponent, Vector3 position) Parameters cameraComponent CameraComponent position Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. Returns Vector3 Position in world coordinates. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null. ScreenToWorldPoint(CameraComponent, ref Vector3, out Vector3) Converts the screen position to a point in world coordinates. public static void ScreenToWorldPoint(this CameraComponent cameraComponent, ref Vector3 position, out Vector3 result) Parameters cameraComponent CameraComponent position Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. result Vector3 Position in world coordinates. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. ScreenToWorldRaySegment(CameraComponent, Vector2) Converts the screen position to a RaySegment in world coordinates. public static RaySegment ScreenToWorldRaySegment(this CameraComponent cameraComponent, Vector2 position) Parameters cameraComponent CameraComponent position Vector2 Returns RaySegment RaySegment, starting at near plain and ending at the far plain. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null. ScreenToWorldRaySegment(CameraComponent, ref Vector2, out RaySegment) Converts the screen position to a RaySegment in world coordinates. public static void ScreenToWorldRaySegment(this CameraComponent cameraComponent, ref Vector2 position, out RaySegment result) Parameters cameraComponent CameraComponent position Vector2 result RaySegment RaySegment, starting at near plain and ending at the far plain. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. WorldToClipSpace(CameraComponent, ref Vector3) Converts the world position to clip space coordinates relative to camera. public static Vector3 WorldToClipSpace(this CameraComponent cameraComponent, ref Vector3 position) Parameters cameraComponent CameraComponent position Vector3 Returns Vector3 Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. WorldToScreenPoint(CameraComponent, Vector3) Converts the world position to screen space coordinates relative to camera. public static Vector3 WorldToScreenPoint(this CameraComponent cameraComponent, Vector3 position) Parameters cameraComponent CameraComponent position Vector3 Returns Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null. WorldToScreenPoint(CameraComponent, ref Vector3, out Vector3) Converts the world position to screen space coordinates relative to camera. public static void WorldToScreenPoint(this CameraComponent cameraComponent, ref Vector3 position, out Vector3 result) Parameters cameraComponent CameraComponent position Vector3 result Vector3 The screen position in normalized X, Y coordinates. Top-left is (0,0), bottom-right is (1,1). Z is in world units from near camera plane. Remarks This method does not update the ViewMatrix or ProjectionMatrix before performing the transformation. If the CameraComponent or it's containing Entity TransformComponenthas been modified since the last frame you may need to call the Update() method first. Exceptions ArgumentNullException If the cameraComponent argument is null."
  },
  "api/Stride.CommunityToolkit.Engine.EntityExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.EntityExtensions.html",
    "title": "Class EntityExtensions | Stride Community Toolkit",
    "keywords": "Class EntityExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Provides extension methods for Entity to simplify common operations. public static class EntityExtensions Inheritance object EntityExtensions Methods AddInteractiveCameraScript(Entity) Adds an interactive camera script BasicCameraController to the specified entity, enabling camera movement and rotation through various input methods. public static void AddInteractiveCameraScript(this Entity entity) Parameters entity Entity The entity to which the interactive camera script will be added. Remarks The camera entity can be moved using W, A, S, D, Q and E, arrow keys, a gamepad's left stick or dragging/scaling using multi-touch. Rotation is achieved using the Numpad, the mouse while holding the right mouse button, a gamepad's right stick, or dragging using single-touch. DestroyEntity(Entity) Attempts to remove the entity from its scene, destroying it. [Obsolete(\"Use Remove() instead\", true)] public static bool DestroyEntity(this Entity entity) Parameters entity Entity Returns bool True if the entity was successfully removed; otherwise, false. GetComponent<T>(Entity) Retrieves the first component of the specified type from the entity. public static T? GetComponent<T>(this Entity entity) Parameters entity Entity Returns T The first component of the specified type, or null if no such component exists. Type Parameters T The type of component to retrieve. GetComponents<T>(Entity) Retrieves all components of the specified type from the entity. public static IEnumerable<T> GetComponents<T>(this Entity entity) Parameters entity Entity Returns IEnumerable<T> An IEnumerable of components of the specified type. Type Parameters T The type of components to retrieve. Remove(Entity) Removes the entity from its current scene by setting its Scene property to null. public static void Remove(this Entity entity) Parameters entity Entity The entity to be removed from its current scene. WorldPosition(Entity, bool) An easier way to get the previous frames world position rather than getting TranslationVector from WorldMatrix public static Vector3 WorldPosition(this Entity entity, bool updateTransforms = true) Parameters entity Entity The Entity to get the World Position updateTransforms bool If true it will get the current frames world matrix Returns Vector3 The Vector3 as the World Position of the Entity"
  },
  "api/Stride.CommunityToolkit.Engine.GameExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Engine.GameExtensions.html",
    "title": "Class GameExtensions | Stride Community Toolkit",
    "keywords": "Class GameExtensions Namespace Stride.CommunityToolkit.Engine Assembly Stride.CommunityToolkit.dll Extensions for Stride.Games.IGame public static class GameExtensions Inheritance object GameExtensions Methods AddCamera(Game, string?, Vector3?, Vector3?) Adds a camera entity to the game's root scene with customizable position and rotation. public static Entity AddCamera(this Game game, string? entityName = null, Vector3? initialPosition = null, Vector3? initialRotation = null) Parameters game Game The Game instance to which the camera entity will be added. entityName string Optional name for the camera entity. If null, the entity will not be named. initialPosition Vector3? Initial position for the camera entity. If null, the camera will be positioned at the default position (6, 6, 6). initialRotation Vector3? Initial rotation for the camera entity specified in degrees. If null, the camera will be rotated to face towards the origin with default angles (Yaw: 45, Pitch: -30, Roll: 0). Returns Entity The created Entity object representing the camera. Remarks The camera entity will be created with a perspective projection mode and will be added to the game's root scene. It will also be assigned to the first available camera slot in the GraphicsCompositor. AddDirectionalLight(Game, string?) Adds a directional light entity to the game's root scene with optional customization. public static Entity AddDirectionalLight(this Game game, string? entityName = null) Parameters game Game The Game instance to which the directional light will be added. entityName string Optional name for the new directional light entity. If null, the entity will not be named. Returns Entity The created Entity object representing the directional light. Remarks This method creates a directional light with the following default settings: Intensity: 20.0f Position: (0, 2.0f, 0) Rotation: X-axis rotated by -30 degrees and Y-axis rotated by -180 degrees. Shadow Enabled: True Shadow Size: Large Shadow Filter: PCF (Percentage Closer Filtering) with a filter size of 5x5 The entity will be added to the game's root scene. You can customize the light properties by accessing the returned Entity object. AddGraphicsCompositor(Game) Adds a default GraphicsCompositor with enabled post-effects to the specified Game instance and sets it as the game's SceneSystem GraphicsCompositor. public static GraphicsCompositor AddGraphicsCompositor(this Game game) Parameters game Game The Game instance to which the GraphicsCompositor will be added. Returns GraphicsCompositor The newly configured GraphicsCompositor instance with enabled post-effects. AddGround(Game, string?, Vector2?, bool) Adds a ground with default Size 10,10. public static Entity AddGround(this Game game, string? entityName = null, Vector2? size = null, bool includeCollider = true) Parameters game Game entityName string size Vector2? includeCollider bool Adds a collider Returns Entity AddProfiler(Game, string?) Adds a profiler to the game, which can be toggled on/off with Left Shift + Left Ctrl + P, and provides other keyboard shortcuts. Changing the filtering mode with F1, altering the sorting mode with F2, navigating result pages with F3 and F4, and adjusting the refresh interval with the plus and minus keys. public static Entity AddProfiler(this Game game, string? entityName = null) Parameters game Game The game to which the profiler will be added. entityName string Optional name for the entity to which the GameProfiler script will be attached. Returns Entity The entity to which the GameProfiler script was attached. Remarks This extension method creates an entity and attaches a GameProfiler script to it, enabling in-game profiling. The profiler's behaviour can be interacted with using various keyboard shortcuts as described in the GameProfiler class. AddSkybox(Game, string?) Adds a skybox to the specified game scene, providing a background texture to create a more immersive environment. public static Entity AddSkybox(this Game game, string? entityName = null) Parameters game Game The game instance to which the skybox will be added. entityName string The name for the skybox entity. If null, a default name will be used. Returns Entity The created skybox entity. Remarks The skybox texture is loaded from the Resources folder, and is used to generate a skybox using the SkyboxGenerator. A new entity is created with a BackgroundComponent and a LightComponent, both configured for the skybox, and is added to the game scene. The default position of the skybox entity is set to (0.0f, 2.0f, -2.0f). CreateMaterial(Game, Color?, float, float) Creates a basic material with optional color, specular reflection, and microsurface smoothness values. public static Material CreateMaterial(this Game game, Color? color = null, float specular = 1, float microSurface = 0.65) Parameters game Game The game instance used to access the graphics device. color Color? The color of the material. Defaults to null, which will use the _defaultMaterialColor. specular float The specular reflection factor of the material. Defaults to 1.0f. microSurface float The microsurface smoothness value of the material. Defaults to 0.65f. Returns Material A new material instance with the specified or default attributes. CreatePrimitive(Game, PrimitiveModelType, string?, Material?, bool, Vector3?) Creates a primitive 3D model entity of the specified type with optional customizations. public static Entity CreatePrimitive(this Game game, PrimitiveModelType type, string? entityName = null, Material? material = null, bool includeCollider = true, Vector3? size = null) Parameters game Game The game instance. type PrimitiveModelType The type of primitive model to create. entityName string The name to assign to the new entity (optional). material Material The material to apply to the model (optional). includeCollider bool Indicates whether to include a collider component (default is true). size Vector3? The size of the model if applicable (optional). Dimensions in the Vector3 are used in the order X, Y, Z. If null, default dimensions are used for the model. Returns Entity A new entity representing the specified primitive model. DeltaTime(IGame) Gets the time elapsed since the last game update in seconds as a single-precision floating-point number. public static float DeltaTime(this IGame gameTime) Parameters gameTime IGame The IGame interface providing access to game timing information. Returns float The time elapsed since the last game update in seconds. DeltaTimeAccurate(IGame) Gets the time elapsed since the last game update in seconds as a double-precision floating-point number. public static double DeltaTimeAccurate(this IGame gameTime) Parameters gameTime IGame The IGame interface providing access to game timing information. Returns double The time elapsed since the last game update in seconds with double precision. FPS(Game) Retrieves the current frames per second (FPS) rate of the running game. public static float FPS(this Game game) Parameters game Game The game instance from which to obtain the FPS rate. Returns float The current FPS rate of the game. Run(Game, GameContext?, Action<Scene>?, Action<Scene, GameTime>?) Initializes the game, starts the game loop, and handles game events. public static void Run(this Game game, GameContext? context = null, Action<Scene>? start = null, Action<Scene, GameTime>? update = null) Parameters game Game The Game instance to initialize and run. context GameContext Optional GameContext to be used. Defaults to null. start Action<Scene> Optional action to execute at the start of the game. Takes the root scene as a parameter. update Action<Scene, GameTime> Optional action to execute during each game loop iteration. Takes the root scene and game time as parameters. Remarks This method performs the following actions: Schedules the root script for execution. Initiates the game loop by calling Run(GameContext). Invokes the provided start and update delegates. SetupBase(Game) Sets up essential components for the game including a GraphicsCompositor, a camera, and a directional light. public static void SetupBase(this Game game) Parameters game Game The Game instance that will receive the base setup. Remarks This method performs the following operations: Adds a default GraphicsCompositor to the game's SceneSystem and applies a clean UI stage. Adds a camera to the game. Adds a directional light to the game. SetupBase3DScene(Game) Sets up a default 3D scene for the game, similar to creating an empty project through the editor. public static void SetupBase3DScene(this Game game) Parameters game Game The Game instance for which the base 3D scene will be set up. Remarks This method performs the following setup operations in sequence: Adds a default GraphicsCompositor to the game's SceneSystem and applies a clean UI stage. Adds a camera to the game and sets it up with a MouseLookCamera component. Adds a directional light to the game scene. Adds a skybox to the game scene. Adds ground geometry to the game scene."
  },
  "api/Stride.CommunityToolkit.Engine.html": {
    "href": "api/Stride.CommunityToolkit.Engine.html",
    "title": "Namespace Stride.CommunityToolkit.Engine | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Engine Classes CameraComponentExtensions EntityExtensions Provides extension methods for Entity to simplify common operations. GameExtensions Extensions for Stride.Games.IGame"
  },
  "api/Stride.CommunityToolkit.Extensions.CameraDefaults.html": {
    "href": "api/Stride.CommunityToolkit.Extensions.CameraDefaults.html",
    "title": "Class CameraDefaults | Stride Community Toolkit",
    "keywords": "Class CameraDefaults Namespace Stride.CommunityToolkit.Extensions Assembly Stride.CommunityToolkit.dll public static class CameraDefaults Inheritance object CameraDefaults Fields InitialPosition Specifies the initial position for a camera within the game or scene. This position is set as (6, 6, 6) by default. public static readonly Vector3 InitialPosition Field Value Vector3 InitialRotation Specifies the initial rotation (in degrees) for a camera within the game or scene. This rotation is set as (45, -30, 0) by default, representing rotations around the X, Y, and Z axes respectively. public static readonly Vector3 InitialRotation Field Value Vector3"
  },
  "api/Stride.CommunityToolkit.Extensions.GraphicsDeviceExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Extensions.GraphicsDeviceExtensions.html",
    "title": "Class GraphicsDeviceExtensions | Stride Community Toolkit",
    "keywords": "Class GraphicsDeviceExtensions Namespace Stride.CommunityToolkit.Extensions Assembly Stride.CommunityToolkit.dll public static class GraphicsDeviceExtensions Inheritance object GraphicsDeviceExtensions Methods GetWindowSize(GraphicsDevice) Retrieves the current window size of the GraphicsDevice as a Int2. public static Int2 GetWindowSize(this GraphicsDevice graphics) Parameters graphics GraphicsDevice The GraphicsDevice for which the window size should be retrieved. Returns Int2 An Int2 representing the current window size, where X is the width and Y is the height."
  },
  "api/Stride.CommunityToolkit.Extensions.html": {
    "href": "api/Stride.CommunityToolkit.Extensions.html",
    "title": "Namespace Stride.CommunityToolkit.Extensions | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Extensions Classes CameraDefaults GraphicsDeviceExtensions"
  },
  "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.FloatRGBAConverter.html": {
    "href": "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.FloatRGBAConverter.html",
    "title": "Struct HeightmapExtensions.FloatRGBAConverter | Stride Community Toolkit",
    "keywords": "Struct HeightmapExtensions.FloatRGBAConverter Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll Float from bytes and back, like the Union structure from c++ public struct HeightmapExtensions.FloatRGBAConverter Inherited Members ValueType.Equals(object) ValueType.GetHashCode() ValueType.ToString() Constructors FloatRGBAConverter(byte, byte, byte, byte) public FloatRGBAConverter(byte r, byte g, byte b, byte a) Parameters r byte g byte b byte a byte FloatRGBAConverter(float) public FloatRGBAConverter(float @float) Parameters float float Fields A public byte A Field Value byte B public byte B Field Value byte Float public float Float Field Value float G public byte G Field Value byte R public byte R Field Value byte"
  },
  "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.VertexTypePosTexNormColor.html": {
    "href": "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.VertexTypePosTexNormColor.html",
    "title": "Struct HeightmapExtensions.VertexTypePosTexNormColor | Stride Community Toolkit",
    "keywords": "Struct HeightmapExtensions.VertexTypePosTexNormColor Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll Custom vertex type so that we can generate tangents for supporting normal maps public struct HeightmapExtensions.VertexTypePosTexNormColor : IEquatable<HeightmapExtensions.VertexTypePosTexNormColor>, IVertex Implements IEquatable<HeightmapExtensions.VertexTypePosTexNormColor> IVertex Constructors VertexTypePosTexNormColor(Vector3, Vector3, Vector3, Vector2, Vector4) public VertexTypePosTexNormColor(Vector3 position, Vector3 normal, Vector3 tangent, Vector2 texCoord1, Vector4 color1) Parameters position Vector3 normal Vector3 tangent Vector3 texCoord1 Vector2 color1 Vector4 Fields Color public Vector4 Color Field Value Vector4 Layout public static readonly VertexDeclaration Layout Field Value VertexDeclaration Normal public Vector3 Normal Field Value Vector3 Position public Vector3 Position Field Value Vector3 Size public static readonly int Size Field Value int Tangent public Vector3 Tangent Field Value Vector3 TexCoord public Vector2 TexCoord Field Value Vector2 Methods Equals(VertexTypePosTexNormColor) Indicates whether the current object is equal to another object of the same type. public bool Equals(HeightmapExtensions.VertexTypePosTexNormColor other) Parameters other HeightmapExtensions.VertexTypePosTexNormColor An object to compare with this object. Returns bool true if the current object is equal to the other parameter; otherwise, false. Equals(object) Indicates whether this instance and a specified object are equal. public override bool Equals(object obj) Parameters obj object The object to compare with the current instance. Returns bool true if obj and this instance are the same type and represent the same value; otherwise, false. FlipWinding() Flip the vertex winding. public void FlipWinding() GetHashCode() Returns the hash code for this instance. public override int GetHashCode() Returns int A 32-bit signed integer that is the hash code for this instance. GetLayout() Gets the layout of the vertex. public VertexDeclaration GetLayout() Returns VertexDeclaration ToString() Returns the fully qualified type name of this instance. public override string ToString() Returns string The fully qualified type name. Operators operator ==(VertexTypePosTexNormColor, VertexTypePosTexNormColor) public static bool operator ==(HeightmapExtensions.VertexTypePosTexNormColor left, HeightmapExtensions.VertexTypePosTexNormColor right) Parameters left HeightmapExtensions.VertexTypePosTexNormColor right HeightmapExtensions.VertexTypePosTexNormColor Returns bool operator !=(VertexTypePosTexNormColor, VertexTypePosTexNormColor) public static bool operator !=(HeightmapExtensions.VertexTypePosTexNormColor left, HeightmapExtensions.VertexTypePosTexNormColor right) Parameters left HeightmapExtensions.VertexTypePosTexNormColor right HeightmapExtensions.VertexTypePosTexNormColor Returns bool"
  },
  "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Physics.HeightmapExtensions.html",
    "title": "Class HeightmapExtensions | Stride Community Toolkit",
    "keywords": "Class HeightmapExtensions Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll public static class HeightmapExtensions Inheritance object HeightmapExtensions Fields HeightMultiplier Used to distinguish between Grey scale heightmaps HeightMultiplier=255.0f (yields a byte 0-255) or float heightmaps HeightMultiplier=10000.0f (based on a short -32,768 to 32,767, sum yields 65,535 levels for much smoother maps). public const float HeightMultiplier = 255 Field Value float Methods AsStrideColor(short) public static Color AsStrideColor(this short val) Parameters val short Returns Color GetHeightAt(Heightmap, int, int) public static float GetHeightAt(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns float GetHeightIndex(Heightmap, int, int) public static int GetHeightIndex(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns int GetNormal(Heightmap, int, int) public static Vector3 GetNormal(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns Vector3 GetTangent(Heightmap, int, int) public static Vector3 GetTangent(this Heightmap heightmap, int x, int z) Parameters heightmap Heightmap x int z int Returns Vector3 IntersectsRay(Heightmap, Ray, out Vector3, float, float) public static bool IntersectsRay(this Heightmap heightmap, Ray ray, out Vector3 point, float m_QuadSideWidthX = 1, float m_QuadSideWidthZ = 1) Parameters heightmap Heightmap ray Ray point Vector3 m_QuadSideWidthX float m_QuadSideWidthZ float Returns bool IsValidCoordinate(Heightmap, int, int) public static bool IsValidCoordinate(this Heightmap heightmap, int x, int y) Parameters heightmap Heightmap x int y int Returns bool ToFloats(Heightmap) public static float[] ToFloats(this Heightmap heightmap) Parameters heightmap Heightmap Returns float[] ToMesh(Heightmap, GraphicsDevice, float, float, float, out Vector3[], int) Creates the terrain mesh from a given heightmap. Tessellation divides the quad numbers. public static Mesh ToMesh(this Heightmap heightmap, GraphicsDevice graphicsDevice, float m_QuadSideWidthX, float m_QuadSideWidthZ, float TEXTURE_REPEAT, out Vector3[] terrainPoints, int tessellation) Parameters heightmap Heightmap graphicsDevice GraphicsDevice m_QuadSideWidthX float m_QuadSideWidthZ float TEXTURE_REPEAT float terrainPoints Vector3[] tessellation int Returns Mesh ToTexture(Heightmap, GraphicsDevice, CommandList) public static Texture ToTexture(this Heightmap heightmap, GraphicsDevice graphicsDevice, CommandList commandList) Parameters heightmap Heightmap graphicsDevice GraphicsDevice commandList CommandList Returns Texture ToWorldPoints(Heightmap, float, float) public static Vector3[] ToWorldPoints(this Heightmap heightmap, float m_QuadSideWidthX, float m_QuadSideWidthZ) Parameters heightmap Heightmap m_QuadSideWidthX float m_QuadSideWidthZ float Returns Vector3[]"
  },
  "api/Stride.CommunityToolkit.Physics.SimulationExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Physics.SimulationExtensions.html",
    "title": "Class SimulationExtensions | Stride Community Toolkit",
    "keywords": "Class SimulationExtensions Namespace Stride.CommunityToolkit.Physics Assembly Stride.CommunityToolkit.dll public static class SimulationExtensions Inheritance object SimulationExtensions Methods Raycast(Simulation, Entity, Vector3, float, CollisionFilterGroupFlags, EFlags) A Raycast method based on the example in the fps demo public static HitResult Raycast(this Simulation simulation, Entity entityPosition, Vector3 direction, float length = 1, CollisionFilterGroupFlags collisionFlags = CollisionFilterGroupFlags.AllFilter, EFlags eFlags = EFlags.None) Parameters simulation Simulation entityPosition Entity direction Vector3 length float collisionFlags CollisionFilterGroupFlags eFlags EFlags Returns HitResult Raycast(Simulation, Entity, float, CollisionFilterGroupFlags, EFlags) A Raycast method based on the example in the fps demo Make sure you are using the actual rotating Entity otherwise you will waste hours like I did debugging a non issue public static HitResult Raycast(this Simulation simulation, Entity entityPosition, float length = 1, CollisionFilterGroupFlags collisionFlags = CollisionFilterGroupFlags.AllFilter, EFlags eFlags = EFlags.None) Parameters simulation Simulation entityPosition Entity length float collisionFlags CollisionFilterGroupFlags eFlags EFlags Returns HitResult"
  },
  "api/Stride.CommunityToolkit.Physics.html": {
    "href": "api/Stride.CommunityToolkit.Physics.html",
    "title": "Namespace Stride.CommunityToolkit.Physics | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Physics Classes HeightmapExtensions SimulationExtensions Structs HeightmapExtensions.FloatRGBAConverter Float from bytes and back, like the Union structure from c++ HeightmapExtensions.VertexTypePosTexNormColor Custom vertex type so that we can generate tangents for supporting normal maps"
  },
  "api/Stride.CommunityToolkit.ProceduralModels.PrimitiveModelType.html": {
    "href": "api/Stride.CommunityToolkit.ProceduralModels.PrimitiveModelType.html",
    "title": "Enum PrimitiveModelType | Stride Community Toolkit",
    "keywords": "Enum PrimitiveModelType Namespace Stride.CommunityToolkit.ProceduralModels Assembly Stride.CommunityToolkit.dll public enum PrimitiveModelType Fields Capsule = 7 Cone = 6 Cube = 1 Cylinder = 2 Plane = 4 Sphere = 0 Teapot = 5 Torus = 3"
  },
  "api/Stride.CommunityToolkit.ProceduralModels.html": {
    "href": "api/Stride.CommunityToolkit.ProceduralModels.html",
    "title": "Namespace Stride.CommunityToolkit.ProceduralModels | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.ProceduralModels Enums PrimitiveModelType"
  },
  "api/Stride.CommunityToolkit.Rendering.Compositing.GraphicsCompositorExtensions.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Compositing.GraphicsCompositorExtensions.html",
    "title": "Class GraphicsCompositorExtensions | Stride Community Toolkit",
    "keywords": "Class GraphicsCompositorExtensions Namespace Stride.CommunityToolkit.Rendering.Compositing Assembly Stride.CommunityToolkit.dll public static class GraphicsCompositorExtensions Inheritance object GraphicsCompositorExtensions Methods AddCleanUIStage(GraphicsCompositor) Adds a UI render stage and white/clean text effect to the given GraphicsCompositor. This alters the GraphicsCompositor's PostProcessingEffects, RenderStage, and RenderFeature. public static GraphicsCompositor AddCleanUIStage(this GraphicsCompositor graphicsCompositor) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor to modify. Returns GraphicsCompositor Returns the modified GraphicsCompositor instance, allowing for method chaining. Examples game.AddGraphicsCompositor().AddCleanUIStage(); AddSceneRenderer(GraphicsCompositor, SceneRendererBase) Adds a new scene renderer to the given GraphicsCompositor's game. If the game is already a collection of scene renderers, the new scene renderer is added to that collection. Otherwise, a new scene renderer collection is created to house both the existing game and the new scene renderer. public static GraphicsCompositor AddSceneRenderer(this GraphicsCompositor graphicsCompositor, SceneRendererBase sceneRenderer) Parameters graphicsCompositor GraphicsCompositor The GraphicsCompositor to which the scene renderer will be added. sceneRenderer SceneRendererBase The new SceneRendererBase instance that will be added to the GraphicsCompositor's game. Returns GraphicsCompositor Returns the modified GraphicsCompositor instance, allowing for method chaining. Remarks This method will either add the scene renderer to an existing SceneRendererCollection or create a new one to house both the existing game and the new scene renderer. In either case, the GraphicsCompositor's game will end up with the new scene renderer added."
  },
  "api/Stride.CommunityToolkit.Rendering.Compositing.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Compositing.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering.Compositing | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Rendering.Compositing Classes GraphicsCompositorExtensions"
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.IndexingType.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.IndexingType.html",
    "title": "Enum IndexingType | Stride Community Toolkit",
    "keywords": "Enum IndexingType Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll public enum IndexingType Fields Int16 = 2 Use a short for vertex indices Int32 = 4 Use a int for vertex indices None = 0 Do not use vertex indexing"
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.MeshBuilder.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.MeshBuilder.html",
    "title": "Class MeshBuilder | Stride Community Toolkit",
    "keywords": "Class MeshBuilder Namespace Stride.CommunityToolkit.Rendering.Utilities Assembly Stride.CommunityToolkit.dll A utility class for building meshes by defining vertex elements with different data types and primitives types. public class MeshBuilder : IDisposable Inheritance object MeshBuilder Implements IDisposable Properties IndexCount The current index count public int IndexCount { get; } Property Value int IndexType The selected index type (default: None) public IndexingType IndexType { get; init; } Property Value IndexingType PrimitiveType The selected primitive type (default: Stride.Graphics.PrimitiveType.TriangleList) public PrimitiveType PrimitiveType { get; init; } Property Value PrimitiveType VertexCount The current vertex count public int VertexCount { get; } Property Value int VertexElements The vertex elements including offsets public IReadOnlyList<VertexElementWithOffset> VertexElements { get; } Property Value IReadOnlyList<VertexElementWithOffset> Methods AddIndex(int) Adds a new vertex index public void AddIndex(int vertexIndex) Parameters vertexIndex int The vertex index Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The vertex index was outside the range of the selected indexing mode InvalidOperationException The mesh builder isn't configured to use indices AddVertex() Adds a new vertex public int AddVertex() Returns int The vertex index (Can be used in GetElement<T>(int, int) and SetElement<T>(int, int, T)) Clear() Clears all buffers and elements configured in this instance public void Clear() Dispose() Performs application-defined tasks associated with freeing, releasing, or resetting unmanaged resources. public void Dispose() GetElement<T>(int) Gets the value for the specified element index public T GetElement<T>(int elementIndex) where T : unmanaged Parameters elementIndex int The element index Returns T The element at the element index Type Parameters T The element type to retrieve Remarks This overload always target's the last vertex index and is a convenience version of GetElement<T>(int, int) Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element GetElement<T>(int, int) Gets the value for the specified element index public T GetElement<T>(int vertexIndex, int elementIndex) where T : unmanaged Parameters vertexIndex int The vertex index elementIndex int The element index Returns T The element at the element index Type Parameters T The element type to retrieve Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element SetElement<T>(int, int, T) Sets the value for the specified element index public void SetElement<T>(int vertexIndex, int elementIndex, T value) where T : unmanaged Parameters vertexIndex int The vertex index elementIndex int The element index value T The value to set Type Parameters T The element type to retrieve Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element SetElement<T>(int, T) Sets the value for the specified element index public void SetElement<T>(int elementIndex, T value) where T : unmanaged Parameters elementIndex int The element index value T The value to set Type Parameters T The element type to retrieve Remarks This overload always target's the last vertex index and is a convenience version of SetElement<T>(int, int, T) Exceptions ArgumentOutOfRangeException The vertex index was outside the range of the currently added vertices ArgumentOutOfRangeException The element index was outside the range of the currently added elements ArgumentException The size of T does not match the type used when defining this element ToMeshDraw(GraphicsDevice, bool) Creates a new mesh draw instance public MeshDraw ToMeshDraw(GraphicsDevice device, bool clear = true) Parameters device GraphicsDevice The graphics device clear bool Determines if the mesh builder should be reset after this call Returns MeshDraw A mesh draw instance Exceptions InvalidOperationException The primitive type was not set to a valid value WithBiTangent<T>(int, string, PixelFormat) Registers a new vertex element public int WithBiTangent<T>(int semanticIndex = 0, string semanticName = \"BITANGENT\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithColor<T>(int, string, PixelFormat) Registers a new vertex element public int WithColor<T>(int semanticIndex = 0, string semanticName = \"COLOR\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithElement<T>(int, string, PixelFormat) Registers a new vertex element public int WithElement<T>(int semanticIndex, string semanticName, PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithIndexType(IndexingType) Changes the selected indexing type. public void WithIndexType(IndexingType indexingType) Parameters indexingType IndexingType The selected indexing type Exceptions InvalidOperationException If vertices were already added changing the indexing type is no longer allowed WithNormal<T>(int, string, PixelFormat) Registers a new vertex element public int WithNormal<T>(int semanticIndex = 0, string semanticName = \"NORMAL\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithPositionTransformed<T>(int, string, PixelFormat) Registers a new vertex element public int WithPositionTransformed<T>(int semanticIndex = 0, string semanticName = \"SV_POSITION\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithPosition<T>(int, string, PixelFormat) Registers a new vertex element public int WithPosition<T>(int semanticIndex = 0, string semanticName = \"POSITION\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithPrimitiveType(PrimitiveType) Changes the selected primitive type. public void WithPrimitiveType(PrimitiveType primitiveType) Parameters primitiveType PrimitiveType The selected primitive type Exceptions InvalidOperationException If vertices were already added changing the primitive type is no longer allowed WithTangent<T>(int, string, PixelFormat) Registers a new vertex element public int WithTangent<T>(int semanticIndex = 0, string semanticName = \"TANGENT\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element WithTextureCoordinate<T>(int, string, PixelFormat) Registers a new vertex element public int WithTextureCoordinate<T>(int semanticIndex = 0, string semanticName = \"TEXCOORD\", PixelFormat pixelFormat = PixelFormat.None) where T : unmanaged Parameters semanticIndex int The semantic index semanticName string The semantic name pixelFormat PixelFormat The pixel format (use Stride.Graphics.PixelFormat.None to auto-detect) Returns int The element index used in GetElement<T>(int) and SetElement<T>(int, T) Type Parameters T The type of the position element"
  },
  "api/Stride.CommunityToolkit.Rendering.Utilities.html": {
    "href": "api/Stride.CommunityToolkit.Rendering.Utilities.html",
    "title": "Namespace Stride.CommunityToolkit.Rendering.Utilities | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Rendering.Utilities Classes MeshBuilder A utility class for building meshes by defining vertex elements with different data types and primitives types. Enums IndexingType"
  },
  "api/Stride.CommunityToolkit.Scripts.BasicCameraController.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.BasicCameraController.html",
    "title": "Class BasicCameraController | Stride Community Toolkit",
    "keywords": "Class BasicCameraController Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll A script that allows to move and rotate an entity through keyboard, mouse and touch input to provide basic camera navigation. public class BasicCameraController : SyncScript, IIdentifiable, ICollectorHolder Inheritance object EntityComponent ScriptComponent StartupScript SyncScript BasicCameraController Implements IIdentifiable ICollectorHolder Inherited Members ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.PriorityUpdated() ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetCamera(ScriptComponent) ScriptComponentExtensions.GetCamera(ScriptComponent, string) ScriptComponentExtensions.GetFirstCamera(ScriptComponent) Remarks The entity can be moved using W, A, S, D, Q and E, arrow keys, a gamepad's left stick or dragging/scaling using multi-touch. Rotation is achieved using the Numpad, the mouse while holding the right mouse button, a gamepad's right stick, or dragging using single-touch. This functionality is inspired by Stride.Assets.Presentation, Assets->Scripts->Camera Properties Gamepad public bool Gamepad { get; set; } Property Value bool KeyboardMovementSpeed public Vector3 KeyboardMovementSpeed { get; set; } Property Value Vector3 KeyboardRotationSpeed public Vector2 KeyboardRotationSpeed { get; set; } Property Value Vector2 MouseRotationSpeed public Vector2 MouseRotationSpeed { get; set; } Property Value Vector2 SpeedFactor public float SpeedFactor { get; set; } Property Value float TouchMovementSpeed public Vector3 TouchMovementSpeed { get; set; } Property Value Vector3 TouchRotationSpeed public Vector2 TouchRotationSpeed { get; set; } Property Value Vector2 Methods Start() Called before the script enters it's update loop. public override void Start() Update() Called every frame. public override void Update()"
  },
  "api/Stride.CommunityToolkit.Scripts.GameProfiler.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.GameProfiler.html",
    "title": "Class GameProfiler | Stride Community Toolkit",
    "keywords": "Class GameProfiler Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll Provides in-game profiling functionality, allowing the monitoring and analysis of game performance in real time. This script facilitates the toggling of profiling, setting display preferences, and navigating through profiling data. public class GameProfiler : AsyncScript, IIdentifiable, ICollectorHolder Inheritance object EntityComponent ScriptComponent AsyncScript GameProfiler Implements IIdentifiable ICollectorHolder Inherited Members AsyncScript.PriorityUpdated() AsyncScript.CancellationToken ScriptComponent.LiveScriptingMask ScriptComponent.ScriptGlobalProfilingKey ScriptComponent.Cancel() ScriptComponent.ProfilingKey ScriptComponent.Audio ScriptComponent.SpriteAnimation ScriptComponent.Services ScriptComponent.Game ScriptComponent.Content ScriptComponent.GameProfiler ScriptComponent.GraphicsDevice ScriptComponent.Input ScriptComponent.Script ScriptComponent.SceneSystem ScriptComponent.EffectSystem ScriptComponent.DebugText ScriptComponent.Streaming ScriptComponent.Log ScriptComponent.Priority ScriptComponent.IsLiveReloading ScriptComponent.Collector EntityComponent.Entity EntityComponent.Id EntityComponent.EnsureEntity Extension Methods ScriptComponentExtensions.DeltaTime(ScriptComponent) ScriptComponentExtensions.GetCamera(ScriptComponent) ScriptComponentExtensions.GetCamera(ScriptComponent, string) ScriptComponentExtensions.GetFirstCamera(ScriptComponent) Remarks This class provides keyboard shortcuts for toggling the profiler on/off with Shift + Ctrl + P, changing the filtering mode with F1, altering the sorting mode with F2, navigating result pages with F3 and F4, and adjusting the refresh interval with the plus and minus keys. Properties Enabled Enables or disable the game profiling public bool Enabled { get; set; } Property Value bool FilteringMode Gets or sets the type of the profiling to display: CPU or GPU [Display(0, \"Filter\", null)] public GameProfilingResults FilteringMode { get; set; } Property Value GameProfilingResults RefreshTime The time between two refreshes of the profiling information in milliseconds. [Display(2, \"Refresh interval (ms)\", null)] public double RefreshTime { get; set; } Property Value double ResultPage Gets or sets the current profiling result page to display. [Display(3, \"Display page\", null)] public uint ResultPage { get; set; } Property Value uint SortingMode Gets or set the sorting mode of the profiling entries [Display(1, \"Sort by\", null)] public GameProfilingSorting SortingMode { get; set; } Property Value GameProfilingSorting TextColor The color of the text displayed during profiling [Display(4, \"Text color\", null)] public Color TextColor { get; set; } Property Value Color Methods Execute() Called once, as a microthread public override Task Execute() Returns Task"
  },
  "api/Stride.CommunityToolkit.Scripts.RaySegment.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.RaySegment.html",
    "title": "Struct RaySegment | Stride Community Toolkit",
    "keywords": "Struct RaySegment Namespace Stride.CommunityToolkit.Scripts Assembly Stride.CommunityToolkit.dll Represents a three dimensional line based on a 2 points in space. [DataContract] public struct RaySegment : IEquatable<RaySegment>, IFormattable Implements IEquatable<RaySegment> IFormattable Constructors RaySegment(Vector3, Vector3) Initializes a new instance of the RaySegment struct. public RaySegment(Vector3 start, Vector3 end) Parameters start Vector3 The position in three dimensional space where the ray starts. end Vector3 The position in three dimensional space where the ray ends. Properties End The position in three dimensional space where the ray ends. public Vector3 End { readonly get; init; } Property Value Vector3 Length Length of RaySegment public float Length { get; } Property Value float Start The position in three dimensional space where the ray starts. public Vector3 Start { readonly get; init; } Property Value Vector3 Methods Equals(RaySegment) Determines whether the specified Vector4 is equal to this instance. public bool Equals(RaySegment value) Parameters value RaySegment The Vector4 to compare with this instance. Returns bool true if the specified Vector4 is equal to this instance; otherwise, false. Equals(object?) Determines whether the specified object is equal to this instance. public override bool Equals(object? value) Parameters value object The object to compare with this instance. Returns bool true if the specified object is equal to this instance; otherwise, false. GetHashCode() Returns a hash code for this instance. public override int GetHashCode() Returns int A hash code for this instance, suitable for use in hashing algorithms and data structures like a hash table. ToString() Returns a string that represents this instance. public override string ToString() Returns string A string that represents this instance. ToString(IFormatProvider) Returns a string that represents this instance. public string ToString(IFormatProvider formatProvider) Parameters formatProvider IFormatProvider The format provider. Returns string A string that represents this instance. ToString(string) Returns a string that represents this instance. public string ToString(string format) Parameters format string The format. Returns string A string that represents this instance. ToString(string?, IFormatProvider?) Returns a string that represents this instance. public string ToString(string? format, IFormatProvider? formatProvider) Parameters format string The format. formatProvider IFormatProvider The format provider. Returns string A string that represents this instance. Operators operator ==(RaySegment, RaySegment) Tests for equality between two objects. public static bool operator ==(RaySegment left, RaySegment right) Parameters left RaySegment The first value to compare. right RaySegment The second value to compare. Returns bool true if left has the same value as right; otherwise, false. explicit operator Ray(RaySegment) Performs an explicit conversion from RaySegment to Ray. public static explicit operator Ray(RaySegment raySegment) Parameters raySegment RaySegment The RaySegment to convert Returns Ray The result of the conversion. operator !=(RaySegment, RaySegment) Tests for inequality between two objects. public static bool operator !=(RaySegment left, RaySegment right) Parameters left RaySegment The first value to compare. right RaySegment The second value to compare. Returns bool true if left has a different value than right; otherwise, false."
  },
  "api/Stride.CommunityToolkit.Scripts.html": {
    "href": "api/Stride.CommunityToolkit.Scripts.html",
    "title": "Namespace Stride.CommunityToolkit.Scripts | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Scripts Classes BasicCameraController A script that allows to move and rotate an entity through keyboard, mouse and touch input to provide basic camera navigation. GameProfiler Provides in-game profiling functionality, allowing the monitoring and analysis of game performance in real time. This script facilitates the toggling of profiling, setting display preferences, and navigating through profiling data. Structs RaySegment Represents a three dimensional line based on a 2 points in space."
  },
  "api/Stride.CommunityToolkit.Skyboxes.SkyboxGenerator.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.SkyboxGenerator.html",
    "title": "Class SkyboxGenerator | Stride Community Toolkit",
    "keywords": "Class SkyboxGenerator Namespace Stride.CommunityToolkit.Skyboxes Assembly Stride.CommunityToolkit.dll public static class SkyboxGenerator Inheritance object SkyboxGenerator Methods Generate(Skybox, SkyboxGeneratorContext, Texture) public static Skybox Generate(Skybox skybox, SkyboxGeneratorContext context, Texture skyboxTexture) Parameters skybox Skybox context SkyboxGeneratorContext skyboxTexture Texture Returns Skybox"
  },
  "api/Stride.CommunityToolkit.Skyboxes.SkyboxGeneratorContext.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.SkyboxGeneratorContext.html",
    "title": "Class SkyboxGeneratorContext | Stride Community Toolkit",
    "keywords": "Class SkyboxGeneratorContext Namespace Stride.CommunityToolkit.Skyboxes Assembly Stride.CommunityToolkit.dll Provides context for generating a skybox by encapsulating relevant services and rendering contexts. public class SkyboxGeneratorContext : ShaderGeneratorContext, IDisposable, IComponent, IReferencable, ICollectorHolder Inheritance object DisposeBase ComponentBase ShaderGeneratorContext SkyboxGeneratorContext Implements IDisposable IComponent IReferencable ICollectorHolder Inherited Members ShaderGeneratorContext.GetParameterKey(ParameterKey) ShaderGeneratorContext.GenerateTextureFromColor(Color) ShaderGeneratorContext.GetTextureKey(Texture, ObjectParameterKey<Texture>, Color?) ShaderGeneratorContext.GetSamplerKey(SamplerStateDescription, GraphicsDevice) ShaderGeneratorContext.GetTextureKey(ComputeTextureBase, MaterialComputeColorKeys) ShaderGeneratorContext.GetSamplerKey(ComputeColorParameterSampler) ShaderGeneratorContext.ResetParameterKeys() ShaderGeneratorContext.PushOverrides(MaterialOverrides) ShaderGeneratorContext.PopOverrides() ShaderGeneratorContext.FindAsset ShaderGeneratorContext.GetAssetFriendlyName ShaderGeneratorContext.Log ShaderGeneratorContext.Content ShaderGeneratorContext.Parameters ShaderGeneratorContext.CurrentOverrides ShaderGeneratorContext.ColorSpace ShaderGeneratorContext.IsNotPixelStage ShaderGeneratorContext.OptimizeMaterials ComponentBase.Tags ComponentBase.Destroy() ComponentBase.OnNameChanged() ComponentBase.ToString() ComponentBase.Name DisposeBase.Dispose() DisposeBase.OnAddReference() DisposeBase.OnReleaseReference() DisposeBase.IsDisposed Remarks This class is a simplified version tailored for code-only usage, inspired by the more complex SkyboxGeneratorContext class in the Stride.Assets.Skyboxes namespace. Constructors SkyboxGeneratorContext(Game) Initializes a new instance of the SkyboxGeneratorContext class using the provided game instance. public SkyboxGeneratorContext(Game game) Parameters game Game The game instance used to access necessary services and contexts. Properties GraphicsDevice Gets the graphics device. public GraphicsDevice GraphicsDevice { get; } Property Value GraphicsDevice RenderContext Gets the render context. public RenderContext RenderContext { get; } Property Value RenderContext RenderDrawContext Gets the render draw context. public RenderDrawContext RenderDrawContext { get; } Property Value RenderDrawContext Services Gets the service registry. public IServiceRegistry Services { get; } Property Value IServiceRegistry"
  },
  "api/Stride.CommunityToolkit.Skyboxes.html": {
    "href": "api/Stride.CommunityToolkit.Skyboxes.html",
    "title": "Namespace Stride.CommunityToolkit.Skyboxes | Stride Community Toolkit",
    "keywords": "Namespace Stride.CommunityToolkit.Skyboxes Classes SkyboxGenerator SkyboxGeneratorContext Provides context for generating a skybox by encapsulating relevant services and rendering contexts."
  },
  "api/Stride.Engine.AnimationComponentExtensions.html": {
    "href": "api/Stride.Engine.AnimationComponentExtensions.html",
    "title": "Class AnimationComponentExtensions | Stride Community Toolkit",
    "keywords": "Class AnimationComponentExtensions Namespace Stride.Engine Assembly Stride.CommunityToolkit.dll public static class AnimationComponentExtensions Inheritance object AnimationComponentExtensions Methods PlayAnimation(AnimationComponent, string) public static void PlayAnimation(this AnimationComponent animationComponent, string name) Parameters animationComponent AnimationComponent name string"
  },
  "api/Stride.Engine.ModelComponentExtensions.html": {
    "href": "api/Stride.Engine.ModelComponentExtensions.html",
    "title": "Class ModelComponentExtensions | Stride Community Toolkit",
    "keywords": "Class ModelComponentExtensions Namespace Stride.Engine Assembly Stride.CommunityToolkit.dll public static class ModelComponentExtensions Inheritance object ModelComponentExtensions Methods GetMeshHWL(ModelComponent) Gets the ModelComponents BoundingBox and calculates the Height, Width and Length public static Vector3 GetMeshHWL(this ModelComponent modelComponent) Parameters modelComponent ModelComponent Returns Vector3 GetMeshHeight(ModelComponent) Gets the ModelComponents BoundingBox and calculates the Y height public static float GetMeshHeight(this ModelComponent modelComponent) Parameters modelComponent ModelComponent Returns float GetMeshVerticesAndIndices(ModelComponent, IGame) Gets the ModelComponents Mesh data as vertices and indices. public static (List<Vector3> verts, List<int> indices) GetMeshVerticesAndIndices(this ModelComponent model, IGame game) Parameters model ModelComponent game IGame Returns (List<Vector3> verts, List<int> indices)"
  },
  "api/Stride.Engine.ScriptComponentExtensions.html": {
    "href": "api/Stride.Engine.ScriptComponentExtensions.html",
    "title": "Class ScriptComponentExtensions | Stride Community Toolkit",
    "keywords": "Class ScriptComponentExtensions Namespace Stride.Engine Assembly Stride.CommunityToolkit.dll public static class ScriptComponentExtensions Inheritance object ScriptComponentExtensions Methods DeltaTime(ScriptComponent) Returns delta time in a shorter format. public static float DeltaTime(this ScriptComponent scriptComponent) Parameters scriptComponent ScriptComponent Returns float GetCamera(ScriptComponent) Gets the camera from the GraphicsCompositor with the name main public static CameraComponent GetCamera(this ScriptComponent scriptComponent) Parameters scriptComponent ScriptComponent Returns CameraComponent Remarks Make sure the Graphics compositor has been initialized with cameras or else this will fail. GetCamera(ScriptComponent, string) Gets the camera from the GraphicsCompositor with the given name. public static CameraComponent GetCamera(this ScriptComponent scriptComponent, string cameraName) Parameters scriptComponent ScriptComponent cameraName string Returns CameraComponent Remarks Make sure the Graphics compositor has been initialized with cameras or else this will fail. GetFirstCamera(ScriptComponent) Gets the first camera from the GraphicsCompositor public static CameraComponent GetFirstCamera(this ScriptComponent scriptComponent) Parameters scriptComponent ScriptComponent Returns CameraComponent Remarks Make sure the Graphics compositor has been initialized with cameras or else this will fail."
  },
  "api/Stride.Engine.html": {
    "href": "api/Stride.Engine.html",
    "title": "Namespace Stride.Engine | Stride Community Toolkit",
    "keywords": "Namespace Stride.Engine Classes AnimationComponentExtensions ModelComponentExtensions ScriptComponentExtensions"
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "Stride Community Toolkit API | Stride API",
    "keywords": "Stride Community Toolkit API Note The Stride Community Toolkit is currently in development. Documentation is incomplete and may contain errors. We published it early for your convenience, ahead of the toolkit's completion. Welcome to the Stride Community Toolkit API documentation. These pages contain detailed information about the Stride scripting API, grouped by namespace. The API documentation covers methods, properties, and other relevant information to help you effectively use the Stride engine in your projects."
  },
  "index.html": {
    "href": "index.html",
    "title": "Stride Community Toolkit Documentation | Stride Community Toolkit",
    "keywords": "Stride Community Toolkit Documentation Note The Stride Community Toolkit is currently in development. Documentation is incomplete and may contain errors. We published it early for your convenience, ahead of the toolkit's completion.  Introduction The Stride Community Toolkit is a comprehensive set of C# helpers and extensions designed to enhance your experience with the Stride Game Engine. It simplifies and exemplifies routine development tasks , enabling you to build applications for Stride using .NET 8 with ease .  Installation Available as a  NuGet package, the Stride Community Toolkit can be easily integrated into new or existing Stride Game C# projects. For more information on how to get started, please refer to the Getting Started page.  Rapid Prototyping and Development This toolkit serves as our preferred solution for rapid  prototyping and accelerated game development. Unlike the more stable Stride Game Engine, the Stride Community Toolkit aims for a faster development momentum. As such, breaking changes are not only likely but should be expected. This approach allows us to quickly iterate and integrate new features and improvements. We believe this pace serves the needs of developers who are looking for cutting-edge tools and are comfortable with a more dynamic environment.  Toolkit Repository The Stride Community Toolkit is an open-source, MIT licensed project hosted on GitHub and supported by the community. Access the source code or contribute  to the toolkit on its GitHub Repository.  Game Engine Repository Access the source code or contribute  to the Stride Game Engine on its GitHub Repository. Explore a comprehensive guide on the Stride Docs website.  Documentation & Resources Explore a range of resources to help you get the most out of the Stride Community Toolkit: Manual: Get detailed guidance and best practices for using the toolkit. Tutorials: Step-by-step tutorials to help you learn various features of the toolkit. Release Notes: Stay updated with the latest changes and improvements. API Reference: In-depth API documentation for a deep dive into the toolkit's capabilities. These resources are designed to provide comprehensive information and support for developers at all levels, from beginners to advanced users.  Contributors This section highlights the amazing contributors who have helped enhance the Stride Community Toolkit with their efforts. DotLogix: Utility MeshBuilder, docs Doprez: Extensions IXLLEGACYIXL: Extensions Vaclav Elias: Code only approach implementation, toolkit docs dfkeenan: Previous toolkit implementation Idomeneas1970: Heightmap extensions"
  },
  "manual/camera-extensions/index.html": {
    "href": "manual/camera-extensions/index.html",
    "title": "Camera Extensions | Stride Manual",
    "keywords": "Camera Extensions"
  },
  "manual/code-only/create-project.html": {
    "href": "manual/code-only/create-project.html",
    "title": "Create Project | Stride Manual",
    "keywords": "Create Project Command Line and Visual Studio Code Instructions The following instructions will guide you through the process of creating a new Stride project using the command line. If you prefer to use Visual Studio Code, you can follow the same instructions in the Visual Studio Code Terminal. Prerequisites: Make sure you have all prerequisites installed. See the Prerequisites section for more information. Create a Console App: Follow the Microsoft tutorial to learn more about how to create a new console application. dotnet new console --framework net6.0 Add NuGet Package: Execute the following command to add the necessary NuGet package. dotnet add package Stride.CommunityToolkit --prerelease Update Program.cs: Paste the example code (below) into your Program.cs file. Build the Project (Optional): The dotnet build command is used to compile your Stride project, generating executable files and checking for any errors in your code. This step is optional as the subsequent dotnet run command will automatically build the project if it hasn't been built already. To manually build the project, execute the following command: dotnet build Run the Project: The dotnet run command will build (if necessary) and execute your project. Run the following command to start your Stride project: dotnet run Enjoy Stride: If everything is set up correctly, you should now be able to run and enjoy your Stride project. Visual Studio 2022 and Rider Instructions Create a C# Console Application: Open Visual Studio 2022 or Rider and create a new C# Console Application targeting .NET 6. Add NuGet Package: Search for and add the Stride.CommunityToolkit NuGet package, ensuring you opt for the pre-release version. This package will install all needed Stride NuGet packages Update Program.cs: Paste the example code (provided below) into your Program.cs file. Run the Project: Build and run your project using the IDE's run functionality. Enjoy Stride: If everything is set up correctly, you should now be able to run and enjoy your Stride project. Example Code The provided C# code example is designed to showcase the basic usage of the Stride Game Engine. using Stride.CommunityToolkit.Extensions; using Stride.CommunityToolkit.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); var entity = game.CreatePrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = rootScene; } using var game = new Game(); creates a new instance of the Game class. The game.Run(start: Start); line starts the game, and it specifies that the Start method should be called when the game begins. void Start(Scene rootScene) is the method that is called when the game starts. It takes in a Scene object, which represents the game scene that is currently being played. Inside the Start method, game.SetupBase3DScene(); sets up a basic 3D scene. var entity = game.CreatePrimitive(PrimitiveModelType.Capsule); creates a new primitive entity of type Capsule, and assigns it to the entity variable. entity.Transform.Position = new Vector3(0, 8, 0); sets the position of the entity in the 3D space. The position is set to (0, 8, 0), which means the capsule is placed 8 units above the ground. entity.Scene = rootScene; adds the entity to the root scene of the game. The CreatePrimitive() method creates a Capsule with rigid body physics. Because the capsule is placed 8 units above the ground, it will fall due to gravity. Note that it's important to remove the capsule from memory once it's no longer visible in the scene, to free up resources and ensure the CPU isn't unnecessarily calculating physics for it Additional Examples Explore more examples listed in the menu on the left, categorized by the programming language and level of complexity. These examples provide a deeper understanding of how to work with a code-only project in Stride, showcasing various functionalities and implementations. The examples are organized under the following sections: C# Basic Examples: Contains basic examples demonstrating fundamental concepts using C#. C# Advanced Examples: Features more advanced scenarios and implementations using C#. F# Basic Examples: Basic examples showcasing fundamental concepts using F#. VB Basic Examples: Demonstrates fundamental concepts using Visual Basic. To view an example, click on its name in the menu, and you will be navigated to a page with a detailed explanation and code snippets."
  },
  "manual/code-only/examples/advance-examples.html": {
    "href": "manual/code-only/examples/advance-examples.html",
    "title": "Code Only Advance Examples | Stride Manual",
    "keywords": "Code Only Advance Examples This page provides a brief overview of the advance examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Myra UI - Draggable Window, GetService(): Demonstrates how to use Myra UI by creating a simple draggable window, displaying a health bar, and accessing registered services. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Give me a cube [5] Basic Example - Stride UI - Capsule with rigid body and Window [6] Basic Example - Procedural Geometry [7] Advance Example - Myra UI - Draggable Window, GetService() [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/basic-examples-fs.html": {
    "href": "manual/code-only/examples/basic-examples-fs.html",
    "title": "F# Code Only Basic Examples | Stride Manual",
    "keywords": "F# Code Only Basic Examples This page provides a brief overview of the basic examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Capsule with rigid body: Demonstrates how to create a 3D capsule entity and position it in a scene. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Give me a cube [5] Basic Example - Stride UI - Capsule with rigid body and Window [6] Basic Example - Procedural Geometry [7] Advance Example - Myra UI - Draggable Window, GetService() [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/basic-examples-vb.html": {
    "href": "manual/code-only/examples/basic-examples-vb.html",
    "title": "Visual Basic Code Only Basic Examples | Stride Manual",
    "keywords": "Visual Basic Code Only Basic Examples This page provides a brief overview of the basic examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Capsule with rigid body: Demonstrates how to create a 3D capsule entity and position it in a scene. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Give me a cube [5] Basic Example - Stride UI - Capsule with rigid body and Window [6] Basic Example - Procedural Geometry [7] Advance Example - Myra UI - Draggable Window, GetService() [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/basic-examples.html": {
    "href": "manual/code-only/examples/basic-examples.html",
    "title": "C# Code Only Basic Examples | Stride Manual",
    "keywords": "C# Code Only Basic Examples This page provides a brief overview of the basic examples available for code-only projects in Stride. You can explore each example in detail. Each linked example page contains detailed code snippets and explanations. Examples Overview Capsule with rigid body: Demonstrates how to create a 3D capsule entity and position it in a scene. Give me a cube: A variation of the above example, positioning a 3D cube in a scene. Stride UI - Capsule with rigid body and Window: Demonstrates how to create a 3D capsule entity and position it in a scene, and how to create a simple window displaying a text message. Procedural geometry: Demonstrates how to create procedural geometry meshes such as a triangle, plane, and circle, and how to add them to a scene. Interactive Console Application For those who prefer a more interactive approach, we provide a console application that allows you to run these examples directly. This console app, available in the Stride.CommunityToolkit.Examples project, offers an interactive menu for selecting and running the examples. Here's a glimpse of the interactive menu provided by the console application: Stride Community Toolkit Examples [1] Basic Example - Capsule with rigid body [2] Basic Example - Capsule with rigid body in F# [3] Basic Example - Capsule with rigid body in Visual Basic [4] Basic Example - Give me a cube [5] Basic Example - Stride UI - Capsule with rigid body and Window [6] Basic Example - Procedural Geometry [7] Advance Example - Myra UI - Draggable Window, GetService() [Q] Quit Enter choice and press ENTER to continue"
  },
  "manual/code-only/examples/capsule-with-rigid-body-fs.html": {
    "href": "manual/code-only/examples/capsule-with-rigid-body-fs.html",
    "title": "Capsule with rigid body in F# | Stride Manual",
    "keywords": "Capsule with rigid body in F# This code example demonstrates how to initialize a game, set up a basic 3D scene, create a 3D capsule entity, set its position, and add it to the scene using the extensions provided by the toolkit. The CreatePrimitive() method, a part of the toolkit, automatically equips the capsule entity with a rigid body and a collider. This example serves as a simple starting point for building a game with Stride, leveraging the utilities provided by the toolkit to simplify common game development tasks. View on GitHub. open Stride.CommunityToolkit.Engine; open Stride.CommunityToolkit.ProceduralModels; open Stride.Core.Mathematics; open Stride.Engine; let game = new Game() let Start rootScene = game.SetupBase3DScene() game.AddProfiler() |> ignore let firstBox = game.CreatePrimitive(PrimitiveModelType.Capsule); firstBox.Transform.Position <- new Vector3(0f, 2.5f, 0f) firstBox.Scene <- rootScene [<EntryPoint>] let main argv = game.Run(start = Start) 0 let game = new Game() Creates a new instance of the Game class, serving as the central part of the Stride engine for managing game loop, scenes, and entities. let Start rootScene = Defines a function named Start that takes a Scene object named rootScene as an argument. game.SetupBase3DScene() Sets up a basic 3D scene with a default camera, lighting, and skybox. game.AddProfiler() |> ignore Adds a profiler to the game and discards the unneeded return value. let firstBox = game.CreatePrimitive(PrimitiveModelType.Capsule); Creates a new 3D capsule primitive entity. firstBox.Transform.Position <- new Vector3(0f, 2.5f, 0f) Sets the 3D position of the created entity. firstBox.Scene <- rootScene Adds the entity to the rootScene. [<EntryPoint>] Specifies that the following main function is the entry point of the application. let main argv = Defines the main function, which will be the entry point for the application. game.Run(start = Start) Initiates the game loop by passing the Start function as the start delegate. 0 Indicates a successful program execution."
  },
  "manual/code-only/examples/capsule-with-rigid-body-vb.html": {
    "href": "manual/code-only/examples/capsule-with-rigid-body-vb.html",
    "title": "Capsule with rigid body in Visual Basic | Stride Manual",
    "keywords": "Capsule with rigid body in Visual Basic This code example demonstrates how to initialize a game, set up a basic 3D scene, create a 3D capsule entity, set its position, and add it to the scene using the extensions provided by the toolkit. The CreatePrimitive() method, a part of the toolkit, automatically equips the capsule entity with a rigid body and a collider. This example serves as a simple starting point for building a game with Stride, leveraging the utilities provided by the toolkit to simplify common game development tasks. View on GitHub. Imports Stride.CommunityToolkit.Engine Imports Stride.CommunityToolkit.ProceduralModels Imports Stride.Core.Mathematics Imports Stride.Engine Module Program Private game As New Game() Sub Main() GameExtensions.Run(game, Nothing, AddressOf StartGame) End Sub Private Sub StartGame(rootScene As Scene) game.SetupBase3DScene() game.AddProfiler() Dim entity = game.CreatePrimitive(PrimitiveModelType.Capsule) entity.Transform.Position = New Vector3(0, 8, 0) entity.Scene = rootScene End Sub End Module Private game As New Game() This line of code creates a new instance of the Game class. The Game class is central to the Stride engine, managing the overall game loop, scenes, and updates to the entities. GameExtensions.Run(game, Nothing, AddressOf StartGame) This line initiates the game loop. The Run method, from GameExtensions, is responsible for starting the game and it takes a reference to the StartGame method as a parameter. This method is called once when the game starts. The Nothing argument here is for an optional parameter that is not being used in this case. game.SetupBase3DScene() This line sets up a basic 3D scene. It's a helper method provided to quickly set up a scene with a default camera, lighting, and skybox. Dim entity = game.CreatePrimitive(PrimitiveModelType.Capsule) Here, a new entity is created in the form of a 3D capsule primitive. The CreatePrimitive method is a helper method provided to create basic 3D shapes. entity.Transform.Position = New Vector3(0, 8, 0) This line sets the position of the created entity in the 3D space. The Position property of the Transform component determines the location of the entity. entity.Scene = rootScene Finally, the entity is added to the rootScene. The Scene property of an entity determines which scene it belongs to."
  },
  "manual/code-only/examples/capsule-with-rigid-body.html": {
    "href": "manual/code-only/examples/capsule-with-rigid-body.html",
    "title": "Capsule with rigid body | Stride Manual",
    "keywords": "Capsule with rigid body This code example demonstrates how to initialize a game, set up a basic 3D scene, create a 3D capsule entity, set its position, and add it to the scene using the extensions provided by the toolkit. The CreatePrimitive() method, a part of the toolkit, automatically equips the capsule entity with a rigid body and a collider. This example serves as a simple starting point for building a game with Stride, leveraging the utilities provided by the toolkit to simplify common game development tasks. View on GitHub. using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using var game = new Game(); game.Run(start: (Scene rootScene) => { game.SetupBase3DScene(); var entity = game.CreatePrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = rootScene; }); using var game = new Game(); This line of code creates a new instance of the Game class. The Game class is the central part of the Stride engine, managing the overall game loop, the scenes, and the updates to the entities. The using keyword ensures that the Dispose() method is called on the game object when it goes out of scope, ensuring that any resources it uses are properly cleaned up game.Run(start: (Scene rootScene) => This line initiates the game loop. The Run method is responsible for starting the game, and it takes a delegate as a parameter. This delegate is a function that is called once when the game starts. The rootScene parameter represents the main scene of your game. game.SetupBase3DScene(); This line sets up a basic 3D scene. It's a helper method provided to quickly set up a scene with a default camera, lighting, and skybox. var entity = game.CreatePrimitive(PrimitiveModelType.Capsule); Here, a new entity is created in the form of a 3D capsule primitive. The CreatePrimitive method is another helper method provided to create basic 3D shapes. entity.Transform.Position = new Vector3(0, 8, 0); This line sets the position of the created entity in the 3D space. The Position property of the Transform component determines the location of the entity. entity.Scene = rootScene; Finally, the entity is added to the rootScene. The Scene property of an entity determines which scene it belongs to."
  },
  "manual/code-only/examples/give-me-cube-body.html": {
    "href": "manual/code-only/examples/give-me-cube-body.html",
    "title": "Give me a cube | Stride Manual",
    "keywords": "Give me a cube This example demonstrates the essential steps to create a 3D cube in Stride. Just like the previous example, the cube entity comes automatically equipped with a rigid body and a collider, thanks to the CreatePrimitive() method. The cube is positioned at (1f, 0.5f, 3f) in the 3D world space. This example is perfect for those who are new to 3D game development with Stride. View on GitHub. using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); var entity = game.CreatePrimitive(PrimitiveModelType.Cube); entity.Transform.Position = new Vector3(1f, 0.5f, 3f); entity.Scene = rootScene; }"
  },
  "manual/code-only/examples/myra-ui-draggable-window-and-services.html": {
    "href": "manual/code-only/examples/myra-ui-draggable-window-and-services.html",
    "title": "Myra UI - Draggable Window, GetService() | Stride Manual",
    "keywords": "Myra UI - Draggable Window, GetService() This example showcases how to integrate Myra, an external UI library, into your game developed with Stride. Myra provides a rich set of widgets and functionalities to enhance the graphical user interface of your game. Key features in this example: Draggable Window: The example demonstrates how to implement a draggable window within the game using Myra's UI components. This draggable window serves as a movable and interactive element that can host other widgets, thus offering a dynamic interface experience for the player. Health Bar: This example features two distinct health bars. The first one is statically defined within the MainView class, while the second is dynamically added during runtime. Both bars can be customized to represent a variety of in-game attributes, such as player health, experience, or other performance metrics. Dynamic Initialization: The UI components, including the health bar, are initialized dynamically during the game's runtime. This allows for greater flexibility and responsiveness in the game's UI. Service Retrieval: The example illustrates the use of GetService() to retrieve services dynamically, thus fostering loose coupling between various components of the game. This practice promotes code reusability and easier maintenance. By following this example, you will gain insights into how to extend your game's capabilities by leveraging external libraries for UI and best practices for service retrieval and dynamic UI component initialization. View on GitHub. using Example04_MyraUI; using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Compositing; using Stride.Engine; using Stride.Games; using var game = new Game(); // State flag to track health bar visibility bool isHealthBarVisible = false; game.Run(start: Start, update: Update); void Start(Scene rootScene) { SetupBase3DScene(); } void Update(Scene rootScene, GameTime time) { InitializeHealthBar(); } void SetupBase3DScene() { game.AddGraphicsCompositor() .AddCleanUIStage() //optional .AddSceneRenderer(new MyraSceneRenderer()); game.AddCamera().AddInteractiveCameraScript(); game.AddDirectionalLight(); game.AddSkybox(); game.AddGround(); } /// <summary> /// Initializes the health bar if it is not already visible. /// </summary> void InitializeHealthBar() { if (isHealthBarVisible) return; var mainView = game.Services.GetService<MainView>(); if (mainView == null) return; // Create and add a new health bar to the main view mainView.Widgets.Add(UIUtils.CreateHealthBar(-50, \"#FFD961FF\")); isHealthBarVisible = true; } MyraSceneRenderer.cs This class provides functionality for rendering Myra-based user interfaces in a Stride game. using Myra; using Myra.Graphics2D.UI; using Stride.Engine; using Stride.Games; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Compositing; namespace Example04_MyraUI; /// <summary> /// Provides functionality for rendering Myra-based user interfaces in a Stride game. /// </summary> /// <remarks> /// This renderer uses the Myra UI library to render the user interface and integrates it into the Stride rendering pipeline. /// </remarks> public class MyraSceneRenderer : SceneRendererBase { /// <summary> /// Gets or sets the root of all UI elements to be rendered. /// </summary> /// <remarks> /// The desktop serves as the root container for all UI elements rendered by Myra. /// </remarks> private Desktop? _desktop; /// <summary> /// Gets or sets the main view of the application UI. /// </summary> /// <remarks> /// The main view contains the primary UI elements that the user will interact with. /// </remarks> private MainView? _mainView; /// <summary> /// Initializes the core rendering properties. /// </summary> /// <remarks> /// This method sets up the Myra environment, configures the main view, and associates it with the desktop. /// </remarks> protected override void InitializeCore() { base.InitializeCore(); MyraEnvironment.Game = (Game)Services.GetService<IGame>(); InitializeMainView(); InitializeDesktop(); } /// <summary> /// Initializes the main view and adds it to the Stride services. /// </summary> private void InitializeMainView() { _mainView = new MainView(); Services.AddService(_mainView); } /// <summary> /// Initializes the desktop and sets the root view. /// </summary> private void InitializeDesktop() { _desktop = new Desktop { Root = _mainView }; } protected override void DrawCore(RenderContext context, RenderDrawContext drawContext) { // Clear depth buffer drawContext.CommandList.Clear(GraphicsDevice.Presenter.DepthStencilBuffer, DepthStencilClearOptions.DepthBuffer); // Render UI _desktop?.Render(); } } MainView.cs This class creates the main UI window MainView and the health bar using HorizontalProgressBar. using Myra.Graphics2D.UI; namespace Example04_MyraUI; /// <summary> /// Represents the main user interface view for the application. /// </summary> /// <remarks> /// The MainView class is responsible for creating and managing key UI elements such as a health bar and a test window. /// </remarks> public class MainView : Panel { /// <summary> /// Gets the health bar UI element. /// </summary> /// <remarks> /// The health bar shows the current health status. /// </remarks> public HorizontalProgressBar HealthBar { get; private set; } = null!; /// <summary> /// Gets the test window UI element. /// </summary> /// <remarks> /// The example window is used for demo purposes and contains a sample label. /// </remarks> public Window ExampleWindow { get; private set; } = null!; /// <summary> /// Initializes a new instance of the <see cref=\"MainView\"/> class. /// </summary> public MainView() { InitializeHealthBar(); InitializeTestWindow(); } /// <summary> /// Initializes the health bar UI element. /// </summary> private void InitializeHealthBar() => Widgets.Add(UIUtils.CreateHealthBar(-20, \"#4BD961FF\")); /// <summary> /// Initializes the test window UI element. /// </summary> private void InitializeTestWindow() { var label = new Label { VerticalSpacing = 10, Text = \"This is a Test! Hello from Myra! This is a window and below two progress bars.\" }; ExampleWindow = new Window { Title = \"Hello From Myra\", Left = 590, Top = 200, Content = label }; Widgets.Add(ExampleWindow); } } UIUtils.cs This class contains helper methods to create UI elements, which are used in multiple places in the example. using Myra.Graphics2D.Brushes; using Myra.Graphics2D.UI; namespace Example04_MyraUI; /// <summary> /// Utility class to create custom UI widgets. /// </summary> public static class UIUtils { /// <summary> /// Creates a new <see cref=\"HorizontalProgressBar\"/> with the given top position and filler color. /// </summary> /// <param name=\"top\">The top position of the progress bar.</param> /// <param name=\"filler\">The filler color of the progress bar.</param> /// <returns>A new <see cref=\"HorizontalProgressBar\"/> instance.</returns> public static HorizontalProgressBar CreateHealthBar(int top, string filler) { return new HorizontalProgressBar { HorizontalAlignment = HorizontalAlignment.Left, VerticalAlignment = VerticalAlignment.Bottom, Value = 100, Filler = new SolidBrush(filler), Left = 20, Top = top, Width = 300, Height = 20, Background = new SolidBrush(\"#202020FF\") }; } } Other Examples Using Myra in Stride Engine Tutorial"
  },
  "manual/code-only/examples/procedural-geometry.html": {
    "href": "manual/code-only/examples/procedural-geometry.html",
    "title": "Procedural geometry | Stride Manual",
    "keywords": "Procedural geometry In this example, we delve into creating procedural geometry meshes including a triangle, a plane, and a circle, and integrate them into a Stride scene. Utilizing the MeshBuilder class from the toolkit, the process of crafting and rendering these geometries is streamlined. The MeshBuilder class is employed to define the layout and data for each mesh. For instance, the GiveMeATriangle, GiveMeAPlane, and GiveMeACircle methods demonstrate how to configure vertices, indices, and other properties to form a triangle, a plane, and a circle, respectively. The Update method demonstrates a dynamic adjustment to the circle's segments count over time, showcasing a simple animation effect. For more details of MeshBuilder, refer to our MeshBuilder manual. View on GitHub. using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.Rendering.Utilities; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Games; using Stride.Graphics; using Stride.Rendering; using Stride.Rendering.Materials; using Stride.Rendering.Materials.ComputeColors; using var game = new Game(); Entity? circleEntity = null; game.Run(start: Start, update: Update); void Start(Scene rootScene) { game.SetupBase3DScene(); AddMesh(game.GraphicsDevice, rootScene, Vector3.Zero, GiveMeATriangle); AddMesh(game.GraphicsDevice, rootScene, Vector3.UnitX * 2, GiveMeAPlane); } void Update(Scene rootScene, GameTime gameTime) { var segments = (int)((Math.Cos(gameTime.Total.TotalMilliseconds / 500) + 1) / 2 * 47) + 3; circleEntity?.Remove(); circleEntity = AddMesh(game.GraphicsDevice, rootScene, Vector3.UnitX * -2, b => GiveMeACircle(b, segments)); } void GiveMeATriangle(MeshBuilder meshBuilder) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color>(); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0, 0, 0)); meshBuilder.SetElement(color, Color.Red); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 0, 0)); meshBuilder.SetElement(color, Color.Green); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(.5f, 1, 0)); meshBuilder.SetElement(color, Color.Blue); meshBuilder.AddIndex(0); meshBuilder.AddIndex(2); meshBuilder.AddIndex(1); } void GiveMeAPlane(MeshBuilder meshBuilder) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color>(); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0, 0, 0)); meshBuilder.SetElement(color, Color.Red); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(0, 1, 0)); meshBuilder.SetElement(color, Color.Green); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 1, 0)); meshBuilder.SetElement(color, Color.Blue); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 0, 0)); meshBuilder.SetElement(color, Color.Yellow); meshBuilder.AddIndex(0); meshBuilder.AddIndex(1); meshBuilder.AddIndex(2); meshBuilder.AddIndex(0); meshBuilder.AddIndex(2); meshBuilder.AddIndex(3); } void GiveMeACircle(MeshBuilder meshBuilder, int segments) { meshBuilder.WithIndexType(IndexingType.Int16); meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color4>(); for (var i = 0; i < segments; i++) { var x = (float)Math.Sin(Math.Tau / segments * i) / 2; var y = (float)Math.Cos(Math.Tau / segments * i) / 2; var hsl = new ColorHSV(360f / segments * i, 1, 1, 1).ToColor(); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(x + .5f, y + .5f, 0)); meshBuilder.SetElement(color, hsl); } meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(.5f, .5f, 0)); meshBuilder.SetElement(color, Color.Black.ToColor4()); for (var i = 0; i < segments; i++) { meshBuilder.AddIndex(segments); meshBuilder.AddIndex(i); meshBuilder.AddIndex((i + 1) % segments); } } Entity AddMesh(GraphicsDevice graphicsDevice, Scene rootScene, Vector3 position, Action<MeshBuilder> build) { using var meshBuilder = new MeshBuilder(); build(meshBuilder); var entity = new Entity { Scene = rootScene, Transform = { Position = position } }; var model = new Model { new MaterialInstance { Material = Material.New(graphicsDevice, new MaterialDescriptor { Attributes = new MaterialAttributes { DiffuseModel = new MaterialDiffuseLambertModelFeature(), Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeVertexStreamColor() }, } }) }, new Mesh { Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 } }; entity.Add(new ModelComponent { Model = model }); return entity; }"
  },
  "manual/code-only/examples/stride-ui-capsule-with-rigid-body.html": {
    "href": "manual/code-only/examples/stride-ui-capsule-with-rigid-body.html",
    "title": "Capsule with rigid body and window | Stride Manual",
    "keywords": "Capsule with rigid body and window In this example, we demonstrate how to set up a 3D scene that includes a capsule with a rigid body as well as a simple window displaying a text message. This example is organized into multiple methods for better readability and maintainability. It is structured as follows: Start(Scene rootScene) This is the entry point for setting up the scene. It calls other methods to set up the 3D scene, add the capsule, load the font, and add the window. AddCapsule(Scene rootScene) This method creates a 3D capsule and adds it to the scene at a specific position. LoadFont() This method loads the font that will be used for the UI window. AddWindow(Scene rootScene) This method calls CreateUIEntity() to create an entity with a UI component, and then adds this entity to the root scene. CreateUIEntity() This method creates an entity that has a UI component. The UI component includes a canvas as its root element. CreateCanvas() This method creates a canvas element that will be the root of the UI component. CreateTextBlock(SpriteFont? _font) This method creates a TextBlock element that displays the message \"Hello, World\". It uses the loaded font and sets other properties like color and size. This modular approach makes the code easier to understand and maintain. Each method has a clear responsibility. View on GitHub. using Stride.CommunityToolkit.Engine; using Stride.CommunityToolkit.ProceduralModels; using Stride.Core.Mathematics; using Stride.Engine; using Stride.Graphics; using Stride.Rendering; using Stride.UI; using Stride.UI.Controls; using Stride.UI.Panels; SpriteFont? _font; using var game = new Game(); game.Run(start: Start); void Start(Scene rootScene) { game.SetupBase3DScene(); AddCapsule(rootScene); LoadFont(); AddWindow(rootScene); } void AddCapsule(Scene rootScene) { var entity = game.CreatePrimitive(PrimitiveModelType.Capsule); entity.Transform.Position = new Vector3(0, 8, 0); entity.Scene = rootScene; } void LoadFont() { _font = game.Content.Load<SpriteFont>(\"StrideDefaultFont\"); } void AddWindow(Scene rootScene) { var uiEntity = CreateUIEntity(); uiEntity.Scene = rootScene; } Entity CreateUIEntity() { return new Entity { new UIComponent { Page = new UIPage { RootElement = CreateCanvas() }, RenderGroup = RenderGroup.Group31 } }; } Canvas CreateCanvas() { var canvas = new Canvas { Width = 300, Height = 100, BackgroundColor = new Color(248, 177, 149, 100) }; canvas.Children.Add(CreateTextBlock(_font)); return canvas; } TextBlock CreateTextBlock(SpriteFont? _font) { if (_font is null) { Console.WriteLine(\"Font is null\"); } return new TextBlock { Text = \"Hello, World\", TextColor = Color.White, TextSize = 20, Margin = new Thickness(3, 3, 3, 0), Font = _font }; }"
  },
  "manual/code-only/extensions.html": {
    "href": "manual/code-only/extensions.html",
    "title": "Extensions | Stride Manual",
    "keywords": "Extensions Each extension has been crafted to address common game development scenarios. They encapsulate and abstract away some of the complexities involved in setting up these scenarios, thus allowing you to focus more on the game logic and less on the setup and configuration. To modify an extension, you can examine its code to understand how it works. Once you grasp the underlying logic, you can modify it or even create a new extension that better suits your needs. Remember, these extensions are just tools to help you get started; don't be afraid to modify them or build your own to align with your unique requirements. In conclusion, whether you are a beginner just starting out with Stride or an experienced developer looking for a quicker way to get your game up and running, these extensions are a valuable resource. They are designed to be a starting point that can be used as is, or can be customised and built upon to create the perfect solution for your game development needs. Remember, the key to mastering Stride, and game development in general, is practice and exploration. So, go ahead, play around with these extensions, and start creating! GameExtensions.cs Some extensions return Entity so it can be further modified. Run() - Initialising the game, use start and update params SetupBase() - Adds graphics compositor, camera and directional light SetupBase3DScene() - Same as SetupBase() plus skybox, ground, mouse look camera AddGraphicsCompositor() - Adds a default GraphicsCompositor AddCamera() - Adds camera AddDirectionalLight() - Adds directional light AddSkybox() - Adds skybox AddGround() - Adds ground GraphicsCompositorExtensions.cs AddCleanUIStage() - Adds a UI render stage and white/clean text effect to the given GraphicsCompositor ScriptComponentExtensions.cs | DeltaTime() || Easier way of getting DeltaTime as a float in seconds | | GetCamera() || Gets the first camera with the name \"Main\", currently doesnt work at the start of a game due to being null in the GraphicsCompositor | | GetCamera(string name) || Gets the first camera with the name provided, currently doesnt work at the start of a game due to being null in the GraphicsCompositor | | GetFirstCamera() || Gets the first camera in the GraphicsCompositor. currently doesnt work at the start of a game due to being null in the GraphicsCompositor | AnimationComponentExtensions.cs | PlayAnimation() || Plays an animation if not already playing | ModelComponentExtensions.cs | GetMeshHeight() || Gets the Mesh height as a float | | GetMeshHWL() || Gets the Mesh height, width and length as a Vector3 |"
  },
  "manual/code-only/index.html": {
    "href": "manual/code-only/index.html",
    "title": "Code Only | Stride Manual",
    "keywords": "Code Only Why Opt for Code-Only Over the Stride Editor? There are numerous reasons to consider using the Code-Only approach, especially if: You prefer not to install additional software on your computer (Stride installation not required). Learn C# or game development in a straightforward, code-first manner. You're aiming for a quick start in game development or C# programming. You're eager to dive into C# or game development, finding joy and educational value in hands-on coding experiences, whether you're new or experienced. You wish to see tangible, visual 2D/3D outputs instead of just console-based results. You want to gradually ease into game programming, mastering the basics before diving into the complexities of a game editor. You find typical coding environments and tools too overwhelming to navigate. You'd like to prototype quickly and easily game elements. You want an efficient way to grasp fundamental game development concepts and practices. You're interested in evaluating performance and features of Stride Game Engine without the overhead of a full-fledged editor. Have more reasons to add? Feel free to suggest them through our GitHub Issues. Extensions and Helpers Our extensions and helpers provide a simplified pathway for game creation, specifically designed for code-only projects within the Stride Game Engine. While they are not essential for running a game, they serve as time-saving tools to aid users, particularly those new to Stride, in quickly getting started. These extensions rely heavily on default settings to ease your initiation into the engine. However, they are not rigid; if the default settings don't fully meet your needs, you have the option to delve into the extension's implementation and create a custom version tailored to your preferences. Please note, although these extensions have been created with an opinionated approach to help beginners get up and running quickly, experienced users can also find value in them. They can serve as a foundation upon which you can build, modify, and extend to create more complex and customised solutions. Functionality Some functionality you would expect and which is working in the Stride Editor might not be possible yet. Please add your vote or submit another request in the GitHub Issues. References https://github.com/stride3d/stride/issues/1295 https://github.com/stride3d/stride/discussions/1253"
  },
  "manual/entity-extensions/index.html": {
    "href": "manual/entity-extensions/index.html",
    "title": "EntityExtensions.cs | Stride Manual",
    "keywords": "EntityExtensions.cs AddInteractiveCameraScript() - Adds an interactive camera script to the specified entity, enabling camera movement and rotation GetComponent<T>() - Retrieves the first component of the specified type from the entity GetComponents<T>() - Retrieves all components of the specified type from the entity Remove() - Removes the entity from its current scene by setting its Scene property to null WorldPosition() - An easier way to get world position"
  },
  "manual/game-extensions/index.html": {
    "href": "manual/game-extensions/index.html",
    "title": "GameExtensions.cs | Stride Manual",
    "keywords": "GameExtensions.cs AddProfiler() - Adds a profiler to the game, which can be toggled on/off with Left Shift + Left Ctrl + P CreateMaterial() - Creates a basic material with optional color, specular reflection, and microsurface smoothness values CreatePrimitive() - Creates a primitive 3D model entity of the specified type with optional customizations DeltaTime() - Gets the time elapsed since the last game update in seconds as a single-precision floating-point number DeltaTimeAccurate() - Gets the time elapsed since the last game update in seconds as a double-precision floating-point FPS() - Retrieves the current frames per second (FPS) rate of the running game AddGizmo() - Debug. To see X,Y,Z arrows AddEntityNames() - Debug. To see entity properties in the game AddPhysicsDebugger() - Debug. To see colliders. Tracked here Issue #9"
  },
  "manual/getting-started.html": {
    "href": "manual/getting-started.html",
    "title": " Get Started | Stride Manual",
    "keywords": " Get Started This article guides you through the initial steps to utilize the packages within the Stride Community Toolkit project.  Prerequisites Ensure the following are installed to build/run the project. If you're on Stride 4.1+ already, these should be pre-installed. Microsoft Visual C++ 2015-2022 Redistributable vcredist_x64.exe (25MB) .NET 8 SDK x64: Download (200MB) Verify installation with: dotnet --info IDE of your choice Visual Studio 2022 Visual Studio 2022 Community (Free) Visual Studio Code (Free, 95MB) Install C# Dev Kit extension Restart Visual Studio Code to ensure dotnet command functions properly Rider (Paid)  Adding the NuGet package The toolkit is encapsulated in a single package named Stride.CommunityToolkit. This package embodies all the toolkit's functionalities. You can use your preferred IDE or the command line to add this package to your project. To add the NuGet package using the command line, execute the following command: dotnet add package Stride.CommunityToolkit --prerelease Use the left navigation to check our extension or dive in code-only section for simple examples."
  },
  "manual/index.html": {
    "href": "manual/index.html",
    "title": "Stride Community Toolkit Manual | Stride Manual",
    "keywords": "Stride Community Toolkit Manual Note The Stride Community Toolkit is currently in development. Documentation is incomplete and may contain errors. We published it early for your convenience, ahead of the toolkit's completion. Welcome to the Stride Community Toolkit Manual. This comprehensive guide is designed to help you make the most of the Stride Community Toolkit for Stride, an open-source C# game engine. Whether you are new to Stride or an experienced developer, these pages offer valuable insights, tips, and detailed instructions to enhance your game development experience. Table of Contents Getting Started: A guide for newcomers on how to set up and start using the Stride Community Toolkit. Code Only Approach: Learn how to create and manage Stride projects using only C# code. Create Project C# Basic Examples Capsule with Rigid Body Give me a Cube Stride UI - Capsule with Rigid Body and Window Procedural Geometry C# Advanced Examples Myra UI - Draggable Window, GetService() F# Basic Examples Capsule with Rigid Body (F#) VB Basic Examples Capsule with Rigid Body (VB) Extensions Entity Extensions: Enhancements and utilities for working with entities. Game Extensions: Additional features and tools for game development. Rendering: A guide on rendering techniques, including using the MeshBuilder. Troubleshooting: Solutions and tips for common issues encountered while using the toolkit. Explore these sections to discover the full potential of the Stride Community Toolkit and enhance your game development skills."
  },
  "manual/rendering/mesh-builder.html": {
    "href": "manual/rendering/mesh-builder.html",
    "title": "MeshBuilder | Stride Manual",
    "keywords": "MeshBuilder Introduction The MeshBuilder is a utility class allowing dynamic creation of meshes at runtime. Acting as a wrapper around the Mesh class, it provides a simpler API for defining the mesh layout and data. Once there was a triangle Like in all rendering examples let's start with a simple triangle. VertexElement A vertex element is a value assigned to a specific vertex. In Stride we can use a lot of different types to define our data some of them are Vector3, Vector4, Color, Int, Float, Half and more. We need to tell Stride how we want layout this data so our shader can read our various values. This is where vertex elements come in. They define a semanticName, semanticIndex, offset and a size. By default Stride allows you to define structs for your data or to use custom buffers for your data. For most use-cases this is probably fine and the easier approach compared to a mesh builder. However if you need to define your data dynamically or want a generalized method here we go. MeshBuilder The MeshBuilder abstracts away a lot of complexity behind custom buffers, type erasure, memory allocation and instead provides you with a simpler builder API to define your mesh dynamically. It uses the same concepts as Stride so you still have to define your layout manually but the process is easier and you don't need to worry about the memory layout yourself. To use a MeshBuilder just create a new instance. using var meshBuilder = new MeshBuilder() Note Notice the using at the front. This part is crucial as you should always dispose of your mesh builder when it's no longer needed. The builder utilizes pooling behind the scenes, and failing to dispose of it prevents the return of internal buffers, which can lead to significant performance degradation. Layout As we discussed earlier we need to tell the MeshBuilder which data types and fields we want to use. For this we use the various With... methods. Primitive Type First we need to select a primitive type in our example we create a bunch of triangles so we use this code: meshBuilder.WithPrimitiveType(PrimitiveType.TriangleList); Indexing The mesh builder supports three types of indexing, None, Int16 or Int32. In our case we definitely don't need more than 32k indices so we can safely use the Int16 version. meshBuilder.WithIndexType(IndexingType.Int16); Elements For our example we will use a vertex with a position and a color element. var position = meshBuilder.WithPosition<Vector3>(); var color = meshBuilder.WithColor<Color>(); These methods return the element index we need when we set our actual values. We use a Vector3 as our vertex position and a Color for our vertex color. Other types would work as well but these are very common so we will use them as well. Vertices Next we define our vertices. For that we use a new method AddVertex(). This will add a new vertex to our builder and allows us to use the Get/SetElement methods. You can also declare multiple vertices before setting the actual values but this is the simplest way for now. meshBuilder.AddVertex(); After this we can set our element data. For this we use the SetElement() method. It expects an element index (which we received from WithPosition and WithColor earlier) as well as your desired value. meshBuilder.SetElement(position, new Vector3(0, 0, 0)); meshBuilder.SetElement(color, Color.Red); We repeat this for the other two triangle points as well. meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(1, 0, 0)); meshBuilder.SetElement(color, Color.Green); meshBuilder.AddVertex(); meshBuilder.SetElement(position, new Vector3(.5f, 1, 0)); meshBuilder.SetElement(color, Color.Blue); Indices Next we need to tell the MeshBuilder how we want to connect the vertices. We configured indexing for our builder so we need to do this explicitly. For a simple example like this you could also completely skip the indexing part and use IndexingType.None instead. The winding order in Stride is counter-clockwise so we use these indices. meshBuilder.AddIndex(0); meshBuilder.AddIndex(2); meshBuilder.AddIndex(1); Mesh The only thing left is building the actual mesh. For this we use this method. It expects a graphics device as an argument. If you call this from a script this is usually available for you using the GraphicsDevice property of your script. meshBuilder.ToMeshDraw(GraphicsDevice); Display To show this MeshDraw on screen we create a ModelComponent and add our MeshDraw as new model. We also need to define a material to use our vertex colors on screen. Else the Triangle would just be white. var model = new Model { new MaterialInstance { Material = Material.New(graphicsDevice, new MaterialDescriptor { Attributes = new MaterialAttributes { DiffuseModel = new MaterialDiffuseLambertModelFeature(), Diffuse = new MaterialDiffuseMapFeature { DiffuseMap = new ComputeVertexStreamColor() }, } }) }, new Mesh { Draw = meshBuilder.ToMeshDraw(graphicsDevice), MaterialIndex = 0 } } Congrats  you got a triangle. Example For a more comprehensive usage of MeshBuilder, explore our Procedural Geometry example where you'll find detailed code on creating complex geometries dynamically."
  },
  "manual/troubleshooting.html": {
    "href": "manual/troubleshooting.html",
    "title": "Troubleshooting | Stride Manual",
    "keywords": "Troubleshooting Building Project Issues Error - Could not load native library libcore using CPU architecture x64 Missing Microsoft Visual C++ Redistributable C:\\Users\\Vacla\\.nuget\\packages\\stride.core.assets.compilerapp\\4.1.0.1728\\buildTransitive\\Stride.Core.Assets.CompilerApp.targets(132,5): error MSB3073: The command \"\"C:\\Users\\Vacla\\.nuget\\packages\\stride.core.assets.compilerapp\\4.1.0.1728\\buildTransitive\\..\\tools\\net6.0-windows7.0\\Stride.Core.Assets.CompilerApp.exe\" --disable-auto- compile --project-configuration \"Debug\" --platform=Windows --project-configuration=Debug --compile-property:StrideGraphicsApi=Direct3D11 --output-path=\"C:\\Projects\\StrideDemo\\bin\\Debug\\net6.0\\data\" --build-path=\"C:\\Projects\\StrideDemo\\obj\\stride\\assetbuild\\data\" --package-file=\"C:\\Projects\\StrideDemo\\StrideDemo.csproj\" --msbuild-up todatecheck-filebase=\"C:\\Projects\\StrideDemo\\obj\\Debug\\net6.0\\stride\\assetcompiler-uptodatecheck\"\" exited with code -532462766. [C:\\Projects\\StrideDemo\\StrideDemo.csproj] Error - Unable to instantiate compiler Missing Microsoft Visual C++ Redistributable EXEC : error 6.206s: [AssetsCompiler.AttributeBasedRegistry] Unable to instantiate compiler [Stride.A ssets.Physics.ColliderShapeAsset, Stride.Assets, Version=4.1.0.1898, Culture=neutral, PublicKeyToken= null]. Exception: TargetInvocationException: Exception has been thrown by the target of an invocation . [C:\\Examples\\Example01\\Example01.csproj] ---> TypeInitializationException: The type initializer for 'Stride.Assets.Physics.ColliderShapeAss etCompiler' threw an exception. ---> InvalidOperationException: Could not load native library VHACD using CPU architecture x64. at Stride.Core.NativeLibraryHelper.PreloadLibrary(String libraryName, Type owner) in C:\\BuildAge nt\\work\\b5f46e3c4829a09e\\sources\\core\\Stride.Core\\Native\\NativeLibraryHelper.cs:line 156 at Stride.Assets.Physics.ColliderShapeAssetCompiler..cctor() in C:\\BuildAgent\\work\\b5f46e3c4829a 09e\\sources\\engine\\Stride.Assets\\Physics\\ColliderShapeAssetCompiler.cs:line 30 at Stride.Assets.Physics.ColliderShapeAssetCompiler..ctor() at System.RuntimeType.CreateInstanceDefaultCtor(Boolean publicOnly, Boolean wrapExceptions) at System.RuntimeType.CreateInstanceDefaultCtor(Boolean publicOnly, Boolean wrapExceptions) at Stride.Core.Assets.Compiler.AssetCompilerRegistry.ProcessAttribute(AssetCompilerAttribute com pilerCompilerAttribute, Type type) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\assets\\Stride.Cor e.Assets\\Compiler\\AssetCompilerRegistry.cs:line 161 at Stride.Core.Assets.Compiler.AssetCompilerRegistry.RegisterCompilersFromAssembly(Assembly asse mbly) in C:\\BuildAgent\\work\\b5f46e3c4829a09e\\sources\\assets\\Stride.Core.Assets\\Compiler\\AssetCompil erRegistry.cs:line 198 System.Reflection.TargetInvocationException: Exception has been thrown by the target of an invocati on."
  },
  "manual/whats-new.html": {
    "href": "manual/whats-new.html",
    "title": "What's new in docs? | Stride Manual",
    "keywords": "What's new in docs? Welcome to what's new in Stride Community Toolkit docs. Use this page to quickly find the latest changes. New articles All content. Updated articles No articles were updated at the moment."
  },
  "release-notes/index.html": {
    "href": "release-notes/index.html",
    "title": "Release Notes | Stride Community Toolkit",
    "keywords": "Release Notes Welcome to the Release Notes for the Stride Community Toolkit. This section aims to provide you with an organized, high-level summary of changes, enhancements, and fixes made in each version release. If you're looking to understand what has changed from one version to the next, you're in the right place. How to Read the Release Notes Each sub-page listed on the left corresponds to a specific version release of the Stride Community Toolkit. These sub-pages will detail new features, improvements, and bug fixes for that particular version. What to Expect The Stride Community Toolkit is developed with rapid iteration in mind. It moves at a faster development pace compared to the Stride Game Engine. As a result, you should expect frequent updates that may introduce breaking changes. This fast-paced approach allows us to incorporate community feedback quickly and continue improving the toolkit."
  },
  "release-notes/stride-community-toolkit-1.0.html": {
    "href": "release-notes/stride-community-toolkit-1.0.html",
    "title": "What's new in Stride Community Toolkit 1.0 | Stride Community Toolkit",
    "keywords": "What's new in Stride Community Toolkit 1.0 This article highlights the most significant changes in Stride Community Toolkit 1.0 with links to relevant documentation. Release notes for 1.0.0.0 What's Changed  Other Changes Update 5 - Content improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/37 38 footer fix the name by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/40 chore: Stride NuGet bumped by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/41 Update 4 - Toolkit Improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/36 Merge NexCoreExtensions into it by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/18 Merged Doprez.Stride extensions by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/20 Add more extensions by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/24 Fix RaySegment by @IXLLEGACYIXL in https://github.com/stride3d/stride-community-toolkit/pull/26 Added docs for Doprez.Stride extensions by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/29 completed basic MyraUI example by @Doprez in https://github.com/stride3d/stride-community-toolkit/pull/30 fix: Updating repo references to stride3d organisation by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/32 feat: GitHub Actions added by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/33 GitHub Actions updated by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/34 Update 3 - GitHub Action improvements by @VaclavElias in https://github.com/stride3d/stride-community-toolkit/pull/35 New Contributors @IXLLEGACYIXL made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/18 @Doprez made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/20 @VaclavElias made their first contribution in https://github.com/stride3d/stride-community-toolkit/pull/32"
  },
  "tutorials/code-only/getting-started.html": {
    "href": "tutorials/code-only/getting-started.html",
    "title": "Get Started | Stride Tutorials",
    "keywords": "Get Started These tutorials cover the code only principles of using C# when working with the Stride game engine."
  },
  "tutorials/code-only/index.html": {
    "href": "tutorials/code-only/index.html",
    "title": "C# Code Only | Stride Tutorials",
    "keywords": "C# Code Only These tutorials cover the code only principles of using C# when working with the Stride game engine."
  },
  "tutorials/index.html": {
    "href": "tutorials/index.html",
    "title": "Stride Game Engine Tutorials | Stride Tutorials",
    "keywords": "Stride Game Engine Tutorials These pages contain tutorials to learn more about the Stride game engine . Stride Tutorials New to Stride? Start with these tutorials to get familiar with the basics of the engine and the Game Studio.  Game Studio - The Stride engine comes with an editor called Game Studio, which is the central tool for game and application production in Stride.  C# Beginner - Covering the beginner principles of using C# when working with the Stride game engine.  C# Intermediate - Diving into intermediate principles of C# programming in Stride, including UI, collisions, and more. Stride Community Toolkit Tutorials Note Under construction"
  }
}